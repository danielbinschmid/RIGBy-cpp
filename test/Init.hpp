///-------------------------------------------------------------------------------------------------
/// 
/// \file test_Init.hpp
/// \brief Some constants Initialisation functions for google tests
/// \author Thibaut Monseigne (Inria).
/// \version 0.1.
/// \date 26/10/2018.
/// \copyright <a href="https://choosealicense.com/licenses/agpl-3.0/">GNU Affero General Public License v3.0</a>.
/// \remarks 
/// - For this tests I compare the results with the <a href="https://github.com/alexandrebarachant/pyRiemann">pyRiemann</a> Python library (<a href="https://github.com/alexandrebarachant/pyRiemann/blob/master/LICENSE">License</a>) or <a href="http://scikit-learn.org">sklearn</a> if pyRiemman just redirect the function.
/// - For the adaptation Classification tests I compare the results with the <a href="https://github.com/alexandrebarachant/covariancetoolbox">covariancetoolbox</a> Matlab library (<a href="https://github.com/alexandrebarachant/covariancetoolbox/blob/master/COPYING">License</a>).
/// 
///-------------------------------------------------------------------------------------------------

#pragma once

#include <vector>
#include <unsupported/Eigen/MatrixFunctions>	// SQRT of Matrix

#include <geometry/classifier/CMatrixClassifierMDM.hpp>
#include <geometry/classifier/CMatrixClassifierFgMDMRT.hpp>
#include <geometry/classifier/CMatrixClassifierMDMRebias.hpp>
#include <geometry/classifier/CMatrixClassifierFgMDM.hpp>
#include <geometry/classifier/CMatrixClassifierFgMDMRTRebias.hpp>

#define NB_CLASS	02
#define NB_CHAN		03
#define NB_SAMPLE	10
#define NB_TRIALS1	07
#define NB_TRIALS2	05
#define NB_TRIALS	12	// NB_TRIALS1 + NB_TRIALS2
#define NB_FEATURES	06	// NB_CHAN * (NB_CHAN + 1) / 2

//*********************************************
//********** Initialisation Datasets **********
//*********************************************
namespace InitDataset {

inline std::vector<Eigen::MatrixXd> FirstClassDataset()
{
	std::vector<Eigen::MatrixXd> result(NB_TRIALS1);
	for (auto& m : result) { m.resize(NB_CHAN, NB_SAMPLE); }

	result[0] << -3, -4, -5, -4, -6, -1, -4, -1, -3, -1,
			0, -3, -3, 1, -2, 1, -2, 1, -1, -1,
			1, 0, 0, 1, 0, 1, 0, 1, 1, 1;

	result[1] << -1, -4, -5, -4, -6, -6, -3, -3, -6, -4,
			-3, -1, 0, -3, 0, 0, -2, -2, -3, -3,
			0, 1, 1, 0, 0, 0, 0, 0, 1, 0;

	result[2] << -4, -2, -4, -5, -3, -1, -6, -3, -3, -4,
			0, -3, -2, -2, -3, 0, -1, -2, -1, -2,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 0;

	result[3] << -5, -3, -1, -1, -2, -4, -1, -6, -4, -4,
			0, 0, -2, -2, -2, 0, 0, -1, 0, 0,
			1, 0, 0, 0, 0, 0, 0, 0, 0, 0;

	result[4] << -2, -1, -5, -2, -6, -5, -6, -4, -6, -6,
			-1, -3, -2, -3, -1, -1, 1, 0, 0, -3,
			0, 1, 1, 0, 0, 1, 1, 0, 0, 1;

	result[5] << -5, -3, -4, -1, -3, -6, -5, -3, -2, -5,
			-2, -3, 1, -3, -1, -2, 0, -1, 1, -2,
			0, 0, 1, 1, 0, 1, 1, 1, 1, 0;

	result[6] << -3, -3, -1, -4, -1, -6, -2, -5, -3, -3,
			-1, -3, -2, 1, 0, 0, -3, -3, -3, 1,
			0, 1, 1, 1, 0, 0, 1, 0, 0, 0;

	return result;
}

inline std::vector<Eigen::MatrixXd> SecondClassDataset()
{
	std::vector<Eigen::MatrixXd> result(NB_TRIALS2);
	for (auto& m : result) { m.resize(NB_CHAN, NB_SAMPLE); }

	result[0] << 0, 3, 1, 1, 2, 3, 1, 3, 3, 2,
			0, 1, 1, -1, -2, 0, -2, 1, 2, 0,
			4, 3, 3, 3, 4, 4, 4, 5, 4, 3;

	result[1] << 3, 2, 1, 2, 1, 2, 3, 3, 1, 4,
			-2, -2, -1, 0, 0, -1, 3, 0, -1, 3,
			4, 4, 3, 4, 3, 5, 5, 4, 5, 4;

	result[2] << 3, 2, 3, 3, 0, 0, 0, 1, 2, 3,
			3, 2, 0, 3, 3, -2, 3, 3, -2, 2,
			5, 3, 4, 4, 5, 4, 3, 3, 5, 4;

	result[3] << 0, 3, 1, 4, 3, 1, 2, 3, 0, 0,
			-2, 1, 1, 0, 2, -1, 3, -1, 2, -2,
			3, 3, 5, 4, 4, 4, 5, 4, 5, 5;

	result[4] << 1, 2, 1, 2, 2, 0, 0, 0, 0, 4,
			1, 3, 0, -2, 1, 0, 0, 2, -2, 2,
			5, 3, 5, 5, 5, 3, 4, 4, 3, 3;

	return result;
}

inline std::vector<std::vector<Eigen::MatrixXd>> Dataset()
{
	std::vector<std::vector<Eigen::MatrixXd>> result;
	result.resize(NB_CLASS);
	result[0] = FirstClassDataset();
	result[1] = SecondClassDataset();
	return result;
}

inline std::vector<Eigen::MatrixXd> DatasetInOneVector()
{
	std::vector<Eigen::MatrixXd> result = FirstClassDataset(), s2 = SecondClassDataset();
	result.insert(result.end(), std::make_move_iterator(s2.begin()), std::make_move_iterator(s2.end()));
	return result;
}

} // namespace InitDataset

//*****************************************************************
//********** Initialisation Basics Reference of Datasets **********
//*****************************************************************
namespace InitBasics {
namespace Center {

inline std::vector<Eigen::MatrixXd> FirstClassReference()
{
	std::vector<Eigen::MatrixXd> result(NB_TRIALS1);
	for (auto& m : result) { m.resize(NB_CHAN, NB_SAMPLE); }

	result[0] << 0.2, -0.8, -1.8, -0.8, -2.8, 2.2, -0.8, 2.2, 0.2, 2.2,
			0.9, -2.1, -2.1, 1.9, -1.1, 1.9, -1.1, 1.9, -0.1, -0.1,
			0.4, -0.6, -0.6, 0.4, -0.6, 0.4, -0.6, 0.4, 0.4, 0.4;

	result[1] << 3.2, 0.2, -0.8, 0.2, -1.8, -1.8, 1.2, 1.2, -1.8, 0.2,
			-1.3, 0.7, 1.7, -1.3, 1.7, 1.7, -0.3, -0.3, -1.3, -1.3,
			-0.3, 0.7, 0.7, -0.3, -0.3, -0.3, -0.3, -0.3, 0.7, -0.3;

	result[2] << -0.5, 1.5, -0.5, -1.5, 0.5, 2.5, -2.5, 0.5, 0.5, -0.5,
			1.6, -1.4, -0.4, -0.4, -1.4, 1.6, 0.6, -0.4, 0.6, -0.4,
			0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, -0.9;

	result[3] << -1.9, 0.1, 2.1, 2.1, 1.1, -0.9, 2.1, -2.9, -0.9, -0.9,
			0.7, 0.7, -1.3, -1.3, -1.3, 0.7, 0.7, -0.3, 0.7, 0.7,
			0.9, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1, -0.1;

	result[4] << 2.3, 3.3, -0.7, 2.3, -1.7, -0.7, -1.7, 0.3, -1.7, -1.7,
			0.3, -1.7, -0.7, -1.7, 0.3, 0.3, 2.3, 1.3, 1.3, -1.7,
			-0.5, 0.5, 0.5, -0.5, -0.5, 0.5, 0.5, -0.5, -0.5, 0.5;

	result[5] << -1.3, 0.7, -0.3, 2.7, 0.7, -2.3, -1.3, 0.7, 1.7, -1.3,
			-0.8, -1.8, 2.2, -1.8, 0.2, -0.8, 1.2, 0.2, 2.2, -0.8,
			-0.6, -0.6, 0.4, 0.4, -0.6, 0.4, 0.4, 0.4, 0.4, -0.6;

	result[6] << 0.1, 0.1, 2.1, -0.9, 2.1, -2.9, 1.1, -1.9, 0.1, 0.1,
			0.3, -1.7, -0.7, 2.3, 1.3, 1.3, -1.7, -1.7, -1.7, 2.3,
			-0.4, 0.6, 0.6, 0.6, -0.4, -0.4, 0.6, -0.4, -0.4, -0.4;

	return result;
}

inline std::vector<Eigen::MatrixXd> SecondClassReference()
{
	std::vector<Eigen::MatrixXd> result(NB_TRIALS2);
	for (auto& m : result) { m.resize(NB_CHAN, NB_SAMPLE); }

	result[0] << -1.9, 1.1, -0.9, -0.9, 0.1, 1.1, -0.9, 1.1, 1.1, 0.1,
			0.0, 1.0, 1.0, -1.0, -2.0, 0.0, -2.0, 1.0, 2.0, 0.0,
			0.3, -0.7, -0.7, -0.7, 0.3, 0.3, 0.3, 1.3, 0.3, -0.7;

	result[1] << 0.8, -0.2, -1.2, -0.2, -1.2, -0.2, 0.8, 0.8, -1.2, 1.8,
			-1.9, -1.9, -0.9, 0.1, 0.1, -0.9, 3.1, 0.1, -0.9, 3.1,
			-0.1, -0.1, -1.1, -0.1, -1.1, 0.9, 0.9, -0.1, 0.9, -0.1;

	result[2] << 1.3, 0.3, 1.3, 1.3, -1.7, -1.7, -1.7, -0.7, 0.3, 1.3,
			1.5, 0.5, -1.5, 1.5, 1.5, -3.5, 1.5, 1.5, -3.5, 0.5,
			1.0, -1.0, 0.0, 0.0, 1.0, 0.0, -1.0, -1.0, 1.0, 0.;

	result[3] << -1.7, 1.3, -0.7, 2.3, 1.3, -0.7, 0.3, 1.3, -1.7, -1.7,
			-2.3, 0.7, 0.7, -0.3, 1.7, -1.3, 2.7, -1.3, 1.7, -2.3,
			-1.2, -1.2, 0.8, -0.2, -0.2, -0.2, 0.8, -0.2, 0.8, 0.8;

	result[4] << -0.2, 0.8, -0.2, 0.8, 0.8, -1.2, -1.2, -1.2, -1.2, 2.8,
			0.5, 2.5, -0.5, -2.5, 0.5, -0.5, -0.5, 1.5, -2.5, 1.5,
			1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 0.0, 0.0, -1.0, -1.;

	return result;
}

inline std::vector<std::vector<Eigen::MatrixXd>> Reference()
{
	std::vector<std::vector<Eigen::MatrixXd>> result;
	result.resize(2);
	result[0] = FirstClassReference();
	result[1] = SecondClassReference();
	return result;
}

} // namespace Center

namespace StandardScaler {

inline std::vector<Eigen::MatrixXd> FirstClassReference()
{
	std::vector<Eigen::MatrixXd> result(NB_TRIALS1);
	for (auto& m : result) { m.resize(NB_CHAN, NB_SAMPLE); }

	result[0] << -3, -4, -5, -4, -6, -1, -4, -1, -3, -1,
			0, -3, -3, 1, -2, 1, -2, 1, -1, -1,
			1, 0, 0, 1, 0, 1, 0, 1, 1, 1;

	result[1] << -1, -4, -5, -4, -6, -6, -3, -3, -6, -4,
			-3, -1, 0, -3, 0, 0, -2, -2, -3, -3,
			0, 1, 1, 0, 0, 0, 0, 0, 1, 0;

	result[2] << -4, -2, -4, -5, -3, -1, -6, -3, -3, -4,
			0, -3, -2, -2, -3, 0, -1, -2, -1, -2,
			1, 1, 1, 1, 1, 1, 1, 1, 1, 0;

	result[3] << -5, -3, -1, -1, -2, -4, -1, -6, -4, -4,
			0, 0, -2, -2, -2, 0, 0, -1, 0, 0,
			1, 0, 0, 0, 0, 0, 0, 0, 0, 0;

	result[4] << -2, -1, -5, -2, -6, -5, -6, -4, -6, -6,
			-1, -3, -2, -3, -1, -1, 1, 0, 0, -3,
			0, 1, 1, 0, 0, 1, 1, 0, 0, 1;

	result[5] << -5, -3, -4, -1, -3, -6, -5, -3, -2, -5,
			-2, -3, 1, -3, -1, -2, 0, -1, 1, -2,
			0, 0, 1, 1, 0, 1, 1, 1, 1, 0;

	result[6] << -3, -3, -1, -4, -1, -6, -2, -5, -3, -3,
			-1, -3, -2, 1, 0, 0, -3, -3, -3, 1,
			0, 1, 1, 1, 0, 0, 1, 0, 0, 0;

	return result;
}

inline std::vector<Eigen::MatrixXd> SecondClassReference()
{
	std::vector<Eigen::MatrixXd> result(NB_TRIALS2);
	for (auto& m : result) { m.resize(NB_CHAN, NB_SAMPLE); }

	result[0] << 0, 3, 1, 1, 2, 3, 1, 3, 3, 2,
			0, 1, 1, -1, -2, 0, -2, 1, 2, 0,
			4, 3, 3, 3, 4, 4, 4, 5, 4, 3;

	result[1] << 3, 2, 1, 2, 1, 2, 3, 3, 1, 4,
			-2, -2, -1, 0, 0, -1, 3, 0, -1, 3,
			4, 4, 3, 4, 3, 5, 5, 4, 5, 4;

	result[2] << 3, 2, 3, 3, 0, 0, 0, 1, 2, 3,
			3, 2, 0, 3, 3, -2, 3, 3, -2, 2,
			5, 3, 4, 4, 5, 4, 3, 3, 5, 4;

	result[3] << 0, 3, 1, 4, 3, 1, 2, 3, 0, 0,
			-2, 1, 1, 0, 2, -1, 3, -1, 2, -2,
			3, 3, 5, 4, 4, 4, 5, 4, 5, 5;

	result[4] << 1, 2, 1, 2, 2, 0, 0, 0, 0, 4,
			1, 3, 0, -2, 1, 0, 0, 2, -2, 2,
			5, 3, 5, 5, 5, 3, 4, 4, 3, 3;

	return result;
}

inline std::vector<std::vector<Eigen::MatrixXd>> Reference()
{
	std::vector<std::vector<Eigen::MatrixXd>> result;
	result.resize(2);
	result[0] = FirstClassReference();
	result[1] = SecondClassReference();
	return result;
}

}  // namespace StandardScaler
}  // namespace InitBasics

//*********************************************************************
//********** Initialisation Covariance Reference of Datasets **********
//*********************************************************************
namespace InitCovariance {

//*********************************
//********* COR Reference *********
//*********************************	
namespace COR {
inline std::vector<Eigen::MatrixXd> FirstClassDataset()
{
	std::vector<Eigen::MatrixXd> result(NB_TRIALS1);
	for (auto& m : result) { m.resize(NB_CHAN, NB_CHAN); }

	result[0] << 1.00, 0.644381009, 0.76178344,
			0.644381009, 1.00, 0.863289805,
			0.76178344, 0.863289805, 1.00;

	result[1] << 1.00, -0.533536825, -0.340914594,
			-0.533536825, 1.00, 0.189177769,
			-0.340914594, 0.189177769, 1.00;

	result[2] << 1.00, -0.00, 0.12253577,
			-0.00, 1.00, 0.13074409,
			0.12253577, 0.13074409, 1.00;

	result[3] << 1.00, -0.503267974, -0.37254902,
			-0.503267974, 1.00, 0.259259259,
			-0.37254902, 0.259259259, 1.00;

	result[4] << 1.00, -0.478994453, -0.162459108,
			-0.478994453, 1.00, -0.222988244,
			-0.162459108, -0.222988244, 1.00;

	result[5] << 1.00, -0.0192192227, 0.164770511,
			-0.0192192227, 1.00, 0.466569475,
			0.164770511, 0.466569475, 1.00;

	result[6] << 1.00, -0.134982027, 0.323733677,
			-0.134982027, 1.00, -0.227429413,
			0.323733677, -0.227429413, 1.00;

	return result;
}

inline std::vector<Eigen::MatrixXd> SecondClassDataset()
{
	std::vector<Eigen::MatrixXd> result(NB_TRIALS2);
	for (auto& m : result) { m.resize(NB_CHAN, NB_CHAN); }

	result[0] << 1.00, 0.4543369, 0.25429847,
			0.4543369, 1.00, 0.00,
			0.25429847, 0.00, 1.00;

	result[1] << 1.00, 0.55233592, 0.26244533,
			0.55233592, 1.00, 0.17647059,
			0.26244533, 0.17647059, 1.00;

	result[2] << 1.00, 0.06024874, 0.20348923,
			0.06024874, 1.00, -0.26318068,
			0.20348923, -0.26318068, 1.00;

	result[3] << 1.00, 0.290334, -0.32046963,
			0.290334, 1.00, 0.35075632,
			-0.32046963, 0.35075632, 1.00;

	result[4] << 1.00, 0.35805744, 0.00,
			0.35805744, 1.00, -0.21428571,
			0.00, -0.21428571, 1.00;

	return result;
}

inline std::vector<std::vector<Eigen::MatrixXd>> Dataset()
{
	std::vector<std::vector<Eigen::MatrixXd>> result;
	result.resize(2);
	result[0] = FirstClassDataset();
	result[1] = SecondClassDataset();
	return result;
}

}  // namespace COR

//*********************************
//********* COV Reference *********
//*********************************	
namespace COV {

inline std::vector<Eigen::MatrixXd> FirstClassDataset()
{
	std::vector<Eigen::MatrixXd> result(NB_TRIALS1);
	for (auto& m : result) { m.resize(NB_CHAN, NB_CHAN); }

	result[0] << 2.76, 1.62, 0.62,
			1.62, 2.29, 0.64,
			0.62, 0.64, 0.24;

	result[1] << 2.36, -1.04, -0.24,
			-1.04, 1.61, 0.11,
			-0.24, 0.11, 0.21;

	result[2] << 1.85, -0.00, 0.05,
			-0.00, 1.04, 0.04,
			0.05, 0.04, 0.09;

	result[3] << 2.89, -0.77, -0.19,
			-0.77, 0.81, 0.07,
			-0.19, 0.07, 0.09;

	result[4] << 3.41, -1.19, -0.15,
			-1.19, 1.81, -0.15,
			-0.15, -0.15, 0.25;

	result[5] << 2.21, -0.04, 0.12,
			-0.04, 1.96, 0.32,
			0.12, 0.32, 0.24;

	result[6] << 2.29, -0.33, 0.24,
			-0.33, 2.61, -0.18,
			0.24, -0.18, 0.24;

	return result;
}

inline std::vector<Eigen::MatrixXd> SecondClassDataset()
{
	std::vector<Eigen::MatrixXd> result(NB_TRIALS2);
	for (auto& m : result) { m.resize(NB_CHAN, NB_CHAN); }

	result[0] << 1.09, 0.60, 0.17,
			0.60, 1.60, 0.00,
			0.17, 0.00, 0.41;

	result[1] << 0.96, 0.92, 0.18,
			0.92, 2.89, 0.21,
			0.18, 0.21, 0.49;

	result[2] << 1.61, 0.15, 0.20,
			0.15, 3.85, -0.40,
			0.20, -0.40, 0.60;

	result[3] << 2.01, 0.69, -0.34,
			0.69, 2.81, 0.44,
			-0.34, 0.44, 0.56;

	result[4] << 1.56, 0.70, 0.00,
			0.70, 2.45, -0.30,
			0.00, -0.30, 0.80;

	return result;
}

inline std::vector<std::vector<Eigen::MatrixXd>> Dataset()
{
	std::vector<std::vector<Eigen::MatrixXd>> result;
	result.resize(2);
	result[0] = FirstClassDataset();
	result[1] = SecondClassDataset();
	return result;
}

}  // namespace COV

//*********************************
//********* LWF Reference *********
//*********************************
namespace LWF {

inline std::vector<Eigen::MatrixXd> FirstClassReference()
{
	std::vector<Eigen::MatrixXd> result(7);
	for (auto& m : result) { m.resize(NB_CHAN, NB_CHAN); }

	result[0] << 2.5849288, 1.33543611, 0.511092833,
			1.33543611, 2.19748746, 0.527579698,
			0.511092833, 0.527579698, 0.507583739;

	result[1] << 1.99839975, -0.650968006, -0.150223386,
			-0.650968006, 1.52895167, 0.0688523853,
			-0.150223386, 0.0688523853, 0.652648582;

	result[2] << 1.21758058, -0.00, 0.013088361,
			-0.00, 1.00554914, 0.0104706888,
			0.013088361, 0.0104706888, 0.756870279;

	result[3] << 2.57527815, -0.621023059, -0.153239456,
			-0.621023059, 0.897709368, 0.0564566417,
			-0.153239456, 0.0564566417, 0.317012482;

	result[4] << 2.87232755, -0.786745664, -0.0991696216,
			-0.786745664, 1.81451826, -0.0991696216,
			-0.0991696216, -0.0991696216, 0.783154191;

	result[5] << 1.64826027, -0.00963569008, 0.0289070702,
			-0.00963569008, 1.5880372, 0.0770855206,
			0.0289070702, 0.0770855206, 1.17370253;

	result[6] << 1.9742694, -0.149321794, 0.108597668,
			-0.149321794, 2.11906629, -0.081448251,
			0.108597668, -0.081448251, 1.04666432;

	return result;
}

inline std::vector<Eigen::MatrixXd> SecondClassReference()
{
	std::vector<Eigen::MatrixXd> result(5);
	for (auto& m : result) { m.resize(NB_CHAN, NB_CHAN); }

	result[0] << 1.06313148, 0.315509839, 0.0893944544,
			0.315509839, 1.33131485, 0.00,
			0.0893944544, 0.00, 0.705553667;

	result[1] << 1.18724478, 0.490413981, 0.0959505616,
			0.490413981, 2.21604802, 0.111942322,
			0.0959505616, 0.111942322, 0.936707201;

	result[2] << 1.86743369, 0.055816941, 0.074422588,
			0.055816941, 2.70096668, -0.148845176,
			0.074422588, -0.148845176, 1.49159963;

	result[3] << 1.89536719, 0.324938579, -0.160114662,
			0.324938579, 2.27210757, 0.20720721,
			-0.160114662, 0.20720721, 1.21252525;

	result[4] << 1.60313579, 0.00319114656, 0.00,
			0.00319114656, 1.6071931, -0.00136763424,
			0.00, -0.00136763424, 1.59967111;

	return result;
}

inline std::vector<std::vector<Eigen::MatrixXd>> Reference()
{
	std::vector<std::vector<Eigen::MatrixXd>> result;
	result.resize(2);
	result[0] = FirstClassReference();
	result[1] = SecondClassReference();
	return result;
}

}  // namespace LWF

//*********************************
//********* MCD Reference *********
//*********************************	
namespace MCD {

inline std::vector<Eigen::MatrixXd> FirstClassReference()
{
	std::vector<Eigen::MatrixXd> result(NB_TRIALS1);
	for (auto& m : result) { m.resize(NB_CHAN, NB_CHAN); }

	result[0] << 2.00, 2.14285714, 0.57142857,
			2.14285714, 2.57142857, 0.71428571,
			0.57142857, 0.71428571, 0.24489796;

	result[1] << 2.85714286, -1.85714286, -0.14285714,
			-1.85714286, 1.26530612, 0.18367347,
			-0.14285714, 0.18367347, 0.20408163;

	result[2] << 1.55102041, -0.69387755, 0.02040816,
			-0.69387755, 0.40816327, -0.02040816,
			0.02040816, -0.02040816, 0.12244898;

	result[3] << 1.63265306, -1.18367347, 0.00,
			-1.18367347, 0.97959184, 0.00,
			0.00, 0.00, 0.00;

	result[4] << 0.53061224, 0.06122449, -0.04081633,
			0.06122449, 1.55102041, -0.2244898,
			-0.04081633, -0.2244898, 0.24489796;

	result[5] << 1.26530612, 0.40816327, 0.08163265,
			0.40816327, 2.12244898, 0.65306122,
			0.08163265, 0.65306122, 0.24489796;

	result[6] << 1.67346939, 0.7755102, 0.24489796,
			0.7755102, 1.26530612, -0.2244898,
			0.24489796, -0.2244898, 0.24489796;

	return result;
}

inline std::vector<Eigen::MatrixXd> SecondClassReference()
{
	std::vector<Eigen::MatrixXd> result(NB_TRIALS2);
	for (auto& m : result) { m.resize(NB_CHAN, NB_CHAN); }

	result[0] << 0.69387755, 0.36734694, 0.06122449,
			0.36734694, 1.3877551, -0.3877551,
			0.06122449, -0.3877551, 0.24489796;

	result[1] << 0.48979592, -0.28571429, 0.14285714,
			-0.28571429, 0.57142857, -0.14285714,
			0.14285714, -0.14285714, 0.57142857;

	result[2] << 1.63265306, -0.2244898, 0.24489796,
			-0.2244898, 0.20408163, 0.10204082,
			0.24489796, 0.10204082, 0.69387755;

	result[3] << 1.71428571, -0.42857143, -0.42857143,
			-0.42857143, 2.12244898, 0.48979592,
			-0.42857143, 0.48979592, 0.24489796;

	result[4] << 0.53061224, 0.26530612, 0.48979592,
			0.26530612, 1.34693878, 0.53061224,
			0.48979592, 0.53061224, 0.69387755;

	return result;
}

inline std::vector<std::vector<Eigen::MatrixXd>> Reference()
{
	std::vector<std::vector<Eigen::MatrixXd>> result;
	result.resize(2);
	result[0] = FirstClassReference();
	result[1] = SecondClassReference();
	return result;
}

}  // namespace MCD

//*********************************
//********* OAS Reference *********
//*********************************	
namespace OAS {

inline std::vector<Eigen::MatrixXd> FirstClassReference()
{
	std::vector<Eigen::MatrixXd> result(NB_TRIALS1);
	for (auto& m : result) { m.resize(NB_CHAN, NB_CHAN); }

	result[0] << 2.34520102, 0.945778241, 0.361964512,
			0.945778241, 2.07080856, 0.373640786,
			0.361964512, 0.373640786, 0.87399042;

	result[1] << 1.83506857, -0.475246188, -0.109672197,
			-0.475246188, 1.49234296, 0.0502664238,
			-0.109672197, 0.0502664238, 0.852588472;

	result[2] << 1.18111558, -0.00, 0.0109600534,
			-0.00, 1.00356272, 0.00876804276,
			0.0109600534, 0.00876804276, 0.795321701;

	result[3] << 2.22680827, -0.45607113, -0.112537032,
			-0.45607113, 0.994823924, 0.0414610118,
			-0.112537032, 0.0414610118, 0.568367802;

	result[4] << 2.53874679, -0.536560096, -0.0676336255,
			-0.536560096, 1.81732146, -0.0676336255,
			-0.0676336255, -0.0676336255, 1.11393175;

	result[5] << 1.47, -0.00, 0.00,
			-0.00, 1.47, 0.00,
			0.00, 0.00, 1.47;

	result[6] << 1.73914927, -0.0147732834, 0.0107442061,
			-0.0147732834, 1.75347488, -0.0080581546,
			0.0107442061, -0.0080581546, 1.64737585;

	return result;
}

inline std::vector<Eigen::MatrixXd> SecondClassReference()
{
	std::vector<Eigen::MatrixXd> result(NB_TRIALS2);
	for (auto& m : result) { m.resize(NB_CHAN, NB_CHAN); }

	result[0] << 1.04056757, 0.07659782, 0.02170272,
			0.07659782, 1.10567572, 0.00,
			0.02170272, 0.00, 0.95375671;

	result[1] << 1.22291898, 0.42297509, 0.08275599,
			0.42297509, 2.11024714, 0.09654866,
			0.08275599, 0.09654866, 1.00683388;

	result[2] << 1.95254699, 0.02467793, 0.03290391,
			0.02467793, 2.32107076, -0.06580782,
			0.03290391, -0.06580782, 1.78638225;

	result[3] << 1.80811047, 0.04705949, -0.02318873,
			0.04705949, 1.86267219, 0.03000895,
			-0.02318873, 0.03000895, 1.70921734;

	result[4] << 1.60333333, 0.00, 0.00,
			0.00, 1.60333333, -0.00,
			0.00, -0.00, 1.60333333;

	return result;
}

inline std::vector<std::vector<Eigen::MatrixXd>> Reference()
{
	std::vector<std::vector<Eigen::MatrixXd>> result;
	result.resize(2);
	result[0] = FirstClassReference();
	result[1] = SecondClassReference();
	return result;
}

}  // namespace OAS

//*********************************
//********* SCM Reference *********
//*********************************	
namespace SCM {

inline std::vector<Eigen::MatrixXd> FirstClassReference()
{
	std::vector<Eigen::MatrixXd> result(NB_TRIALS1);
	for (auto& m : result) { m.resize(NB_CHAN, NB_CHAN); }

	result[0] << 0.77844311, 0.26946108, -0.07784431,
			0.26946108, 0.18562874, 0.00598802,
			-0.07784431, 0.00598802, 0.03592814;

	result[1] << 0.80645161, 0.24596774, -0.06048387,
			0.24596774, 0.18145161, -0.01612903,
			-0.06048387, -0.01612903, 0.01209677;

	result[2] << 0.75806452, 0.30107527, -0.16666667,
			0.30107527, 0.19354839, -0.07526882,
			-0.16666667, -0.07526882, 0.0483871;

	result[3] << 0.89928058, 0.10071942, -0.03597122,
			0.10071942, 0.09352518, 0.00,
			-0.03597122, 0.00, 0.00719424;

	result[4] << 0.84555985, 0.16988417, -0.08880309,
			0.16988417, 0.13513514, -0.03088803,
			-0.08880309, -0.03088803, 0.01930502;

	result[5] << 0.79899497, 0.22110553, -0.10552764,
			0.22110553, 0.17085427, -0.0201005,
			-0.10552764, -0.0201005, 0.03015075;

	result[6] << 0.71686747, 0.22289157, -0.06024096,
			0.22289157, 0.25903614, -0.04216867,
			-0.06024096, -0.04216867, 0.02409639;

	return result;
}

inline std::vector<Eigen::MatrixXd> SecondClassReference()
{
	std::vector<Eigen::MatrixXd> result(NB_TRIALS2);
	for (auto& m : result) { m.resize(NB_CHAN, NB_CHAN); }

	result[0] << 0.23039216, 0.02941176, 0.35294118,
			0.02941176, 0.07843137, 0.00,
			0.35294118, 0.00, 0.69117647;

	result[1] << 0.22307692, 0.02692308, 0.35384615,
			0.02692308, 0.11153846, -0.00769231,
			0.35384615, -0.00769231, 0.66538462;

	result[2] << 0.16544118, 0.09926471, 0.25735294,
			0.09926471, 0.22426471, 0.20588235,
			0.25735294, 0.20588235, 0.61029412;

	result[3] << 0.18846154, 0.04615385, 0.26153846,
			0.04615385, 0.11153846, 0.06538462,
			0.26153846, 0.06538462, 0.70;

	result[4] << 0.13333333, 0.05777778, 0.21333333,
			0.05777778, 0.12, 0.07555556,
			0.21333333, 0.07555556, 0.74666667;

	return result;
}

inline std::vector<std::vector<Eigen::MatrixXd>> Reference()
{
	std::vector<std::vector<Eigen::MatrixXd>> result;
	result.resize(2);
	result[0] = FirstClassReference();
	result[1] = SecondClassReference();
	return result;
}

}  // namespace SCM
}  // namespace InitCovariance

//****************************************************************
//********** Initialisation Means Reference of Datasets **********
//****************************************************************
namespace InitMeans {
//************************************
//********** Mean Euclidian **********
//************************************	
namespace Euclidian {
inline Eigen::MatrixXd Reference()
{
	Eigen::MatrixXd result(NB_CHAN, NB_CHAN);
	result << 1.87394645, 0.02563437, 0.0298922,
			0.02563437, 1.7732458, 0.06073032,
			0.0298922, 0.06073032, 0.93197441;

	return result;
}
}  // namespace Euclidian

//****************************************
//********** Mean Log Euclidian **********
//****************************************	
namespace LogEuclidian {
inline Eigen::MatrixXd Reference()
{
	Eigen::MatrixXd result(NB_CHAN, NB_CHAN);
	result << 1.7137077, 0.01869396, 0.02040996,
			0.01869396, 1.60430933, 0.0512624,
			0.02040996, 0.0512624, 0.82767414;

	return result;
}
}  // namespace LogEuclidian

//**********************************
//********** Mean Riemann **********
//**********************************	
namespace Riemann {
inline Eigen::MatrixXd Reference()
{
	Eigen::MatrixXd result(NB_CHAN, NB_CHAN);
	result << 1.70952664, 0.01674082, 0.02077766,
			0.01674082, 1.60344581, 0.05423902,
			0.02077766, 0.05423902, 0.8303257;

	return result;
}
}  // namespace Riemann

//******************************************
//********** Mean Log Determinant **********
//******************************************	
namespace LogDeterminant {
inline Eigen::MatrixXd Reference()
{
	Eigen::MatrixXd result(NB_CHAN, NB_CHAN);
	result << 1.70798275, 0.01610538, 0.02003787,
			0.01610538, 1.60581809, 0.05385499,
			0.02003787, 0.05385499, 0.83577899;

	return result;
}
}  // namespace LogDeterminant

//***********************************
//********** Mean Kullback **********
//***********************************	
namespace Kullback {
inline Eigen::MatrixXd Reference()
{
	Eigen::MatrixXd result(NB_CHAN, NB_CHAN);
	result << 1.71301511, 0.01811099, 0.02219169,
			0.01811099, 1.59879804, 0.0548546,
			0.02219169, 0.0548546, 0.81958134;

	return result;
}
}  // namespace Kullback

//**************************************
//********** Mean Wasserstein **********
//**************************************	
namespace Wasserstein {
inline Eigen::MatrixXd Reference()
{
	Eigen::MatrixXd result(NB_CHAN, NB_CHAN);
	result << 1.79643838, 0.0229425, 0.02418139,
			0.0229425, 1.69012112, 0.05311422,
			0.02418139, 0.05311422, 0.87927152;

	return result;
}
}  // namespace Wasserstein

//******************************
//********** Mean ALE **********
//******************************	
namespace ALE {
inline Eigen::MatrixXd Reference()
{
	Eigen::MatrixXd result(NB_CHAN, NB_CHAN);
	result << 1.70133202, 0.01256147, 0.01500743,
			0.01256147, 1.61096286, 0.05925685,
			0.01500743, 0.05925685, 0.83062499;

	return result;
}
}  // namespace ALE

//***********************************
//********** Mean Harmonic **********
//***********************************	
namespace Harmonic {
inline Eigen::MatrixXd Reference()
{
	Eigen::MatrixXd result(NB_CHAN, NB_CHAN);
	result << 1.56594664, 0.01175612, 0.01576697,
			0.01175612, 1.44152542, 0.04955601,
			0.01576697, 0.04955601, 0.72075273;

	return result;
}
}  // namespace Harmonic

//***********************************
//********** Mean Identity **********
//***********************************	
namespace Identity {
inline Eigen::MatrixXd Reference()
{
	Eigen::MatrixXd result(NB_CHAN, NB_CHAN);
	result << 1, 0, 0,
			0, 1, 0,
			0, 0, 1;

	return result;
}
}  // namespace Identity
}  // namespace InitMeans

//*******************************************************************
//********** Initialisation Distance Reference of Datasets **********
//*******************************************************************
namespace InitDistance {
//************************************
//********** Distance Euclidian **********
//************************************	
namespace Euclidian {
inline std::vector<double> Reference()
{
	return std::vector<double>{
		2.27941886, 1.06479476, 1.02847791, 1.59375373, 1.55723736, 0.38300632, 0.50680192, 1.04235464, 1.05530485, 1.12584212, 0.7888681, 0.74648348
	};
}
}

//****************************************
//********** Distance Log Euclidian **********
//****************************************	
namespace LogEuclidian {
inline std::vector<double> Reference()
{
	return std::vector<double>{
		1.32256326, 0.66407543, 0.58679669, 1.40770199, 0.74410706, 0.35240113, 0.43103276, 0.71149032, 0.67768624, 0.80611325, 0.59020555, 0.66716464
	};
}
}

//**********************************
//********** Distance Riemann **********
//**********************************	
namespace Riemann {
inline std::vector<double> Reference()
{
	return std::vector<double>{
		1.32849591, 0.66514346, 0.58560532, 1.41024439, 0.747409, 0.34896944, 0.43236778, 0.71205324, 0.67698377, 0.80599981, 0.59091178, 0.66423683
	};
}
}

//******************************************
//********** Distance Log Determinant **********
//******************************************	
namespace LogDeterminant {
inline std::vector<double> Reference()
{
	return std::vector<double>{
		0.46451334, 0.23505451, 0.20685864, 0.49230328, 0.26223382, 0.1207747, 0.15093304, 0.25002132, 0.23755315, 0.28080601, 0.20652205, 0.23046043
	};
}
}

//***********************************
//********** Distance Kullback **********
//***********************************	
namespace Kullback {
inline std::vector<double> Reference()
{
	return std::vector<double>{
		0.9229355, 0.22182567, 0.17231943, 1.04684976, 0.28821354, 0.06625571, 0.09835624, 0.26108052, 0.23637438, 0.34499747, 0.18292577, 0.238331
	};
}
}

//**************************************
//********** Distance Wasserstein **********
//**************************************	
namespace Wasserstein {
inline std::vector<double> Reference()
{
	return std::vector<double>{
		0.80006691, 0.41547827, 0.38690865, 0.70393068, 0.5282644, 0.16253726, 0.22475651, 0.42258195, 0.41676291, 0.45835023, 0.32884, 0.33947315
	};
}
}
}  // namespace InitDistance

//********************************************************************
//********** Initialisation Geodesics Reference of Datasets **********
//********************************************************************
namespace InitGeodesics {
//****************************************
//********** Geodesic Euclidian **********
//****************************************	
namespace Euclidian {
inline std::vector<Eigen::MatrixXd> Reference()
{
	std::vector<Eigen::MatrixXd> result(NB_TRIALS);
	for (auto& m : result) { m.resize(NB_CHAN, NB_CHAN); }

	result[0] << 2.22943763, 0.68053524, 0.27049252,
			0.68053524, 1.98536663, 0.29415501,
			0.27049252, 0.29415501, 0.71977908;

	result[1] << 1.9361731, -0.31266682, -0.06016559,
			-0.31266682, 1.65109873, 0.06479135,
			-0.06016559, 0.06479135, 0.7923115;

	result[2] << 1.54576352, 0.01281718, 0.02149028,
			0.01281718, 1.38939747, 0.0356005,
			0.02149028, 0.0356005, 0.84442235;

	result[3] << 2.2246123, -0.29769435, -0.06167363,
			-0.29769435, 1.33547758, 0.05859348,
			-0.06167363, 0.05859348, 0.62449345;

	result[4] << 2.373137, -0.38055565, -0.03463871,
			-0.38055565, 1.79388203, -0.01921965,
			-0.03463871, -0.01921965, 0.8575643;

	result[5] << 1.76110336, 0.00799934, 0.02939964,
			0.00799934, 1.6806415, 0.06890792,
			0.02939964, 0.06890792, 1.05283847;

	result[6] << 1.92410792, -0.06184371, 0.06924493,
			-0.06184371, 1.94615604, -0.01035897,
			0.06924493, -0.01035897, 0.98931936;

	result[7] << 1.46853897, 0.1705721, 0.05964333,
			0.1705721, 1.55228032, 0.03036516,
			0.05964333, 0.03036516, 0.81876404;

	result[8] << 1.53059562, 0.25802417, 0.06292138,
			0.25802417, 1.99464691, 0.08633632,
			0.06292138, 0.08633632, 0.93434081;

	result[9] << 1.87069007, 0.04072565, 0.05215739,
			0.04072565, 2.23710624, -0.04405743,
			0.05215739, -0.04405743, 1.21178702;

	result[10] << 1.88465682, 0.17528647, -0.06511123,
			0.17528647, 2.02267668, 0.13396876,
			-0.06511123, 0.13396876, 1.07224983;

	result[11] << 1.73854112, 0.01441276, 0.0149461,
			0.01441276, 1.69021945, 0.02968134,
			0.0149461, 0.02968134, 1.26582276;

	return result;
}
}  // namespace Euclidian

//********************************************
//********** Geodesic Log Euclidian **********
//********************************************	
namespace LogEuclidian {
inline std::vector<Eigen::MatrixXd> Reference()
{
	std::vector<Eigen::MatrixXd> result(NB_TRIALS);
	for (auto& m : result) { m.resize(NB_CHAN, NB_CHAN); }

	result[0] << 2.01103272, 0.58044721, 0.23030037,
			0.58044721, 1.77828904, 0.26574646,
			0.23030037, 0.26574646, 0.6023019;

	result[1] << 1.81637234, -0.31288558, -0.06584287,
			-0.31288558, 1.53243541, 0.05115564,
			-0.06584287, 0.05115564, 0.73216466;

	result[2] << 1.4444758, 0.00763339, 0.01637287,
			0.00763339, 1.26999275, 0.02815584,
			0.01637287, 0.02815584, 0.79133167;

	result[3] << 2.07025711, -0.31144095, -0.0706513,
			-0.31144095, 1.15689355, 0.04576328,
			-0.0706513, 0.04576328, 0.50801127;

	result[4] << 2.18793303, -0.32983868, -0.04048647,
			-0.32983868, 1.66866414, -0.02994009,
			-0.04048647, -0.02994009, 0.80134643;

	result[5] << 1.68059619, 0.00433328, 0.02441754,
			0.00433328, 1.59603546, 0.06329015,
			0.02441754, 0.06329015, 0.98561446;

	result[6] << 1.83708447, -0.05588412, 0.05925687,
			-0.05588412, 1.84057265, -0.00582606,
			0.05925687, -0.00582606, 0.92893714;

	result[7] << 1.335889, 0.19615591, 0.06355339,
			0.19615591, 1.45048646, 0.02049389,
			0.06355339, 0.02049389, 0.7631058;

	result[8] << 1.40437247, 0.25649803, 0.0592415,
			0.25649803, 1.87131332, 0.07613302,
			0.0592415, 0.07613302, 0.87989762;

	result[9] << 1.78864325, 0.03549975, 0.0439749,
			0.03549975, 2.07865681, -0.02282802,
			0.0439749, -0.02282802, 1.10866339;

	result[10] << 1.79329993, 0.1583345, -0.06293884,
			0.1583345, 1.90312554, 0.12069132,
			-0.06293884, 0.12069132, 0.99837833;

	result[11] << 1.65744301, 0.01070952, 0.01156087,
			0.01070952, 1.60544202, 0.0292213,
			0.01156087, 0.0292213, 1.15020022;

	return result;
}
}  // namespace LogEuclidian

//**************************************
//********** Geodesic Riemann **********
//**************************************	
namespace Riemann {
inline std::vector<Eigen::MatrixXd> Reference()
{
	std::vector<Eigen::MatrixXd> result(NB_TRIALS);
	for (auto& m : result) { m.resize(NB_CHAN, NB_CHAN); }

	result[0] << 2.00307073, 0.5751925, 0.23695849,
			0.5751925, 1.77486363, 0.2733501,
			0.23695849, 0.2733501, 0.60804774;

	result[1] << 1.81293091, -0.3138307, -0.06654136,
			-0.3138307, 1.53280236, 0.05341941,
			-0.06654136, 0.05341941, 0.73374953;

	result[2] << 1.44271566, 0.00683161, 0.01652821,
			0.00683161, 1.26962877, 0.029471,
			0.01652821, 0.029471, 0.79258189;

	result[3] << 2.06594851, -0.31310631, -0.07385619,
			-0.31310631, 1.15755075, 0.04790018,
			-0.07385619, 0.04790018, 0.50936876;

	result[4] << 2.18427308, -0.33178678, -0.04048067,
			-0.33178678, 1.66810514, -0.02812001,
			-0.04048067, -0.02812001, 0.8032214;

	result[5] << 1.67854712, 0.00337028, 0.0244905,
			0.00337028, 1.59559946, 0.06467602,
			0.0244905, 0.06467602, 0.98719569;

	result[6] << 1.8346388, -0.05653261, 0.05946108,
			-0.05653261, 1.83958383, -0.0043761,
			0.05946108, -0.0043761, 0.93070402;

	result[7] << 1.33364155, 0.19528644, 0.06320392,
			0.19528644, 1.45004209, 0.02219171,
			0.06320392, 0.02219171, 0.76451583;

	result[8] << 1.40188907, 0.2548021, 0.05901919,
			0.2548021, 1.8711256, 0.0781204,
			0.05901919, 0.0781204, 0.88141717;

	result[9] << 1.78638224, 0.03454505, 0.04380908,
			0.03454505, 2.07716326, -0.02075452,
			0.04380908, -0.02075452, 1.11079047;

	result[10] << 1.78975606, 0.15752572, -0.06172564,
			0.15752572, 1.90245691, 0.12203188,
			-0.06172564, 0.12203188, 1.00070996;

	result[11] << 1.65542219, 0.00974451, 0.01178106,
			0.00974451, 1.60497797, 0.03095649,
			0.01178106, 0.03095649, 1.15199633;

	return result;
}
}  // namespace Riemann
}  // namespace InitGeodesics

//************************************************************************
//********** Initialisation Featurization Reference of Datasets **********
//************************************************************************
namespace InitFeaturization {
namespace TangentSpace {
inline std::vector<Eigen::RowVectorXd> Reference()
{
	std::vector<Eigen::RowVectorXd> result(NB_TRIALS);
	for (auto& m : result) { m.resize(NB_FEATURES); }

	result[0] << 0.19923529, 0.81954961, 0.45583261, 0.06265258, 0.53984445, -0.74189243;
	result[1] << 0.08020799, -0.56380364, -0.19863986, -0.12711376, -0.00487228, -0.24993702;
	result[2] << -0.33927073, -0.0139971, -0.00466568, -0.46577928, -0.04826772, -0.09127522;
	result[3] << 0.34039208, -0.59873603, -0.23557737, -0.70072935, 0.02089894, -0.98360691;
	result[4] << 0.4605308, -0.52546299, -0.14067914, 0.04677775, -0.21048792, -0.06431401;
	result[5] << -0.0365709, -0.02310847, 0.00568693, -0.0103298, 0.01443795, 0.34577556;
	result[6] << 0.13870707, -0.11420977, 0.08057211, 0.27541021, -0.14045981, 0.22931806;
	result[7] << -0.52065199, 0.37104578, 0.12469995, -0.21855289, -0.08508472, -0.16646769;
	result[8] << -0.42665126, 0.41541091, 0.08741089, 0.28616558, 0.02832375, 0.11565408;
	result[9] << 0.08700644, 0.0237524, 0.04023502, 0.51858937, -0.17189999, 0.58429274;
	result[10] << 0.08116035, 0.22060811, -0.19108877, 0.32966629, 0.12395396, 0.36518821;
	result[11] << -0.06409514, -0.01104878, -0.02378668, 0.00324331, -0.06638659, 0.65726463;

	return result;
}
}  // namespace TangentSpace

namespace Squeeze {
inline std::vector<Eigen::RowVectorXd> Reference()
{
	std::vector<Eigen::RowVectorXd> result(NB_TRIALS);
	for (auto& m : result) { m.resize(NB_FEATURES); }

	result[0] << 2.58492880, 1.33543611, 0.511092833, 2.19748746, 0.527579698, 0.507583739;
	result[1] << 1.99839975, -0.650968006, -0.150223386, 1.52895167, 0.0688523853, 0.652648582;
	result[2] << 1.21758058, -0.000000000, 0.0130883610, 1.00554914, 0.0104706888, 0.756870279;
	result[3] << 2.57527815, -0.621023059, -0.153239456, 0.897709368, 0.0564566417, 0.317012482;
	result[4] << 2.87232755, -0.786745664, -0.0991696216, 1.81451826, -0.0991696216, 0.783154191;
	result[5] << 1.64826027, -0.00963569008, 0.0289070702, 1.58803720, 0.0770855206, 1.17370253;
	result[6] << 1.97426940, -0.149321794, 0.108597668, 2.11906629, -0.0814482510, 1.04666432;
	result[7] << 1.06313148, 0.315509839, 0.0893944544, 1.33131485, 0.00000000, 0.705553667;
	result[8] << 1.18724478, 0.490413981, 0.0959505616, 2.21604802, 0.111942322, 0.936707201;
	result[9] << 1.86743369, 0.0558169410, 0.0744225880, 2.70096668, -0.148845176, 1.49159963;
	result[10] << 1.89536719, 0.324938579, -0.160114662, 2.27210757, 0.207207210, 1.21252525;
	result[11] << 1.60313579, 0.00319114656, 0.00000000, 1.60719310, -0.00136763424, 1.59967111;

	return result;
}
}  // namespace Squeeze

namespace SqueezeDiag {
inline std::vector<Eigen::RowVectorXd> Reference()
{
	std::vector<Eigen::RowVectorXd> result(NB_TRIALS);
	for (auto& m : result) { m.resize(NB_FEATURES); }

	result[0] << 2.5849288, 2.19748746, 0.507583739, 1.33543611, 0.527579698, 0.511092833;
	result[1] << 1.99839975, 1.52895167, 0.652648582, -0.650968006, 0.0688523853, -0.150223386;
	result[2] << 1.21758058, 1.00554914, 0.756870279, -0.00, 0.0104706888, 0.013088361;
	result[3] << 2.57527815, 0.897709368, 0.317012482, -0.621023059, 0.0564566417, -0.153239456;
	result[4] << 2.87232755, 1.81451826, 0.783154191, -0.786745664, -0.0991696216, -0.0991696216;
	result[5] << 1.64826027, 1.5880372, 1.17370253, -0.00963569008, 0.0770855206, 0.0289070702;
	result[6] << 1.9742694, 2.11906629, 1.04666432, -0.149321794, -0.081448251, 0.108597668;
	result[7] << 1.06313148, 1.33131485, 0.705553667, 0.315509839, 0.00, 0.0893944544;
	result[8] << 1.18724478, 2.21604802, 0.936707201, 0.490413981, 0.111942322, 0.0959505616;
	result[9] << 1.86743369, 2.70096668, 1.49159963, 0.055816941, -0.148845176, 0.074422588;
	result[10] << 1.89536719, 2.27210757, 1.21252525, 0.324938579, 0.20720721, -0.160114662;
	result[11] << 1.60313579, 1.6071931, 1.59967111, 0.00319114656, -0.00136763424, 0.00;

	return result;
}
}  // namespace SqueezeDiag
}  // namespace InitFeaturization

//**********************************************************************
//********** Initialisation Classifiers Reference of Datasets **********
//**********************************************************************
namespace InitClassif {
//**************************
//********** LSQR **********
//**************************
namespace LSQR {
inline Eigen::MatrixXd Reference()
{
	Eigen::MatrixXd result(1, NB_FEATURES);
	result << -5.62849964, 2.57528317, -0.41393163, 3.79788328, -1.7915752, 3.63071567;
	return result;
}
}

//**********************************
//********** FgDA Compute **********
//**********************************
namespace FgDACompute {
inline Eigen::MatrixXd Reference()
{
	Eigen::MatrixXd result(NB_FEATURES, NB_FEATURES);
	result << 0.45714834, -0.20916523, 0.03361964, -0.30846516, 0.14551225, -0.29488776,
			-0.20916523, 0.09570218, -0.01538245, 0.14113622, -0.06657818, 0.13492396,
			0.03361964, -0.01538245, 0.00247246, -0.02268517, 0.01070127, -0.02168666,
			-0.30846516, 0.14113622, -0.02268517, 0.20813978, -0.09818576, 0.1989783,
			0.14551225, -0.06657818, 0.01070127, -0.09818576, 0.04631716, -0.09386402,
			-0.29488776, 0.13492396, -0.02168666, 0.1989783, -0.09386402, 0.19022007;
	return result;
}
}  // namespace FgDACompute
}  // namespace InitClassif

//*****************************************************************************
//********** Initialisation Matrix Classifiers Reference of Datasets **********
//*****************************************************************************
namespace InitMatrixClassif {
namespace MDM {
inline Geometry::CMatrixClassifierMDM Reference()
{
	Geometry::CMatrixClassifierMDM result(NB_CLASS, Geometry::EMetric::Riemann);
	std::vector<Eigen::MatrixXd> means(NB_CLASS, Eigen::MatrixXd(NB_CHAN, NB_CHAN));

	means[0] << 1.92849739, -0.1538202, 0.01072518,
			-0.1538202, 1.41817199, 0.06326929,
			0.01072518, 0.06326929, 0.6661666;

	means[1] << 1.46525466, 0.258979, 0.03170221,
			0.258979, 1.94533383, 0.03574208,
			0.03170221, 0.03574208, 1.13153112;

	result.setMeans(means);
	result.setTrialNumbers({ NB_TRIALS1, NB_TRIALS2 });
	return result;
}

//The estimation method of riemann mean in matlab is different of the python and c++ method 
inline Geometry::CMatrixClassifierMDM ReferenceMatlab()
{
	Geometry::CMatrixClassifierMDM result(NB_CLASS, Geometry::EMetric::Riemann);
	std::vector<Eigen::MatrixXd> means(NB_CLASS, Eigen::MatrixXd(NB_CHAN, NB_CHAN));

	means[0] << 1.928499437649616, -0.153827038574370, 0.010747690754065,
			-0.153827038574370, 1.418162423365369, 0.063273476393445,
			0.010747690754065, 0.063273476393445, 0.666171737852679;

	means[1] << 1.465253745853043, 0.258978164753603, 0.031701951674564,
			0.258978164753603, 1.945334998390171, 0.035741956583496,
			0.031701951674564, 0.035741956583496, 1.131530964874486;

	result.setMeans(means);
	result.setTrialNumbers({ NB_TRIALS1, NB_TRIALS2 });
	return result;
}

inline Geometry::CMatrixClassifierMDM AfterSupervised()
{
	Geometry::CMatrixClassifierMDM result(NB_CLASS, Geometry::EMetric::Riemann);
	std::vector<Eigen::MatrixXd> means(NB_CLASS, Eigen::MatrixXd(NB_CHAN, NB_CHAN));

	means[0] << 1.928350313881734, -0.154041423123185, 0.010701374534393,
			-0.154041423123186, 1.418273608417471, 0.063257455871936,
			0.010701374534394, 0.063257455871936, 0.666184815487807;

	means[1] << 1.465233762087830, 0.258934832669209, 0.031704171892215,
			0.258934832669209, 1.945307843854343, 0.035766052240045,
			0.031704171892215, 0.035766052240044, 1.131554685966728;

	result.setMeans(means);
	result.setTrialNumbers({ 2 * NB_TRIALS1, 2 * NB_TRIALS2 });
	return result;
}

inline Geometry::CMatrixClassifierMDM AfterUnSupervised()
{
	Geometry::CMatrixClassifierMDM result(NB_CLASS, Geometry::EMetric::Riemann);
	std::vector<Eigen::MatrixXd> means(NB_CLASS, Eigen::MatrixXd(NB_CHAN, NB_CHAN));

	means[0] << 1.950943868870711, -0.167140250323899, 0.003222724880780,
			-0.167140250323900, 1.360332213689968, 0.069395646598480,
			0.003222724880780, 0.069395646598480, 0.612498166151011;

	means[1] << 1.512203012203314, 0.207413861919226, 0.036590552326957,
			0.207413861919226, 1.921307138623116, 0.030422979119863,
			0.036590552326957, 0.030422979119864, 1.127225044244057;

	result.setMeans(means);
	result.setTrialNumbers({ NB_TRIALS1 + 5, NB_TRIALS2 + 7 });// Find 5 & 7 times in Prediction
	return result;
}

inline std::vector<size_t> Prediction() { return std::vector<size_t>{ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1 }; }
inline std::vector<size_t> PredictionSupervised() { return std::vector<size_t>{ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1 }; }
inline std::vector<size_t> PredictionUnSupervised() { return std::vector<size_t>{ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1 }; }

inline std::vector<std::vector<double>> PredictionDistance()
{
	std::vector<std::vector<double>> result(NB_TRIALS);
	result[0]  = { 1.314629453210111, 1.474855008515000 };
	result[1]  = { 0.464333729201812, 1.051817099896226 };
	result[2]  = { 0.601426917411240, 0.812445189801618 };
	result[3]  = { 1.102877219889465, 1.849548724985433 };
	result[4]  = { 0.626116626250442, 1.067153960330500 };
	result[5]  = { 0.611993241506318, 0.331147184884182 };
	result[6]  = { 0.635248202449675, 0.476499934085104 };
	result[7]  = { 0.845377609077804, 0.747547515688392 };
	result[8]  = { 0.951093615508598, 0.413321379328445 };
	result[9]  = { 1.067347359524113, 0.552344271253539 };
	result[10] = { 0.856508614439436, 0.390553678952617 };
	result[11] = { 0.921536704800470, 0.459953813816839 };
	return result;
}

inline std::vector<std::vector<double>> PredictionDistanceSupervised()
{
	std::vector<std::vector<double>> result(NB_TRIALS);
	result[0]  = { 1.314629453210111, 1.474855008515000 };
	result[1]  = { 0.605125609448517, 1.051817099896226 };
	result[2]  = { 0.632177503835419, 0.812445189801618 };
	result[3]  = { 1.114890656799339, 1.849548724985433 };
	result[4]  = { 0.716307916402446, 1.067153960330500 };
	result[5]  = { 0.705594944810905, 0.331147184884182 };
	result[6]  = { 0.684063787503923, 0.476499934085104 };
	result[7]  = { 0.845432339540137, 0.747547515688392 };
	result[8]  = { 0.951119668632168, 0.353451074348013 };
	result[9]  = { 1.067314379382615, 0.686650119070229 };
	result[10] = { 0.856525175953122, 0.448063104241547 };
	result[11] = { 0.921512070536392, 0.511024366753348 };
	return result;
}

inline std::vector<std::vector<double>> PredictionDistanceUnSupervised()
{
	std::vector<std::vector<double>> result(NB_TRIALS);
	result[0]  = { 1.314629453210111, 1.474855008515000 };
	result[1]  = { 0.605125609448517, 1.051817099896226 };
	result[2]  = { 0.632177503835419, 0.812445189801618 };
	result[3]  = { 1.114890656799339, 1.849548724985433 };
	result[4]  = { 0.716307916402446, 1.067153960330500 };
	result[5]  = { 0.705594944810905, 0.331147184884182 };
	result[6]  = { 0.729161284837321, 0.448637450763909 };
	result[7]  = { 0.871245756539967, 0.786138798955233 };
	result[8]  = { 1.017636018350342, 0.439519359143378 };
	result[9]  = { 1.163460730752319, 0.623259567590992 };
	result[10] = { 0.942113031918693, 0.422541764097218 };
	result[11] = { 1.014624974936401, 0.472684060628136 };

	return result;
}
}  // namespace MDM

namespace FgMDMRT {
inline Geometry::CMatrixClassifierFgMDMRT Reference()
{
	Geometry::CMatrixClassifierFgMDMRT result(NB_CLASS, Geometry::EMetric::Riemann);
	std::vector<Eigen::MatrixXd> means(NB_CLASS, Eigen::MatrixXd(NB_CHAN, NB_CHAN));

	means[0] << 2.08042432, -0.08968098, 0.03145977,
			-0.08968098, 1.41163613, 0.09127538,
			0.03145977, 0.09127538, 0.734828;

	means[1] << 1.30840283, 0.15716713, 0.00232698,
			0.15716713, 1.93455782, -0.01963492,
			0.00232698, -0.01963492, 0.98852719;

	Eigen::MatrixXd ref(NB_CHAN, NB_CHAN);
	ref << 1.70952664, 0.01674082, 0.02077766,
			0.01674082, 1.60344581, 0.05423902,
			0.02077766, 0.05423902, 0.8303257;

	Eigen::MatrixXd weight = Eigen::MatrixXd(NB_FEATURES, NB_FEATURES);
	weight << 0.45714834, -0.20916523, 0.03361964, -0.30846516, 0.14551225, -0.29488776,
			-0.20916523, 0.09570218, -0.01538245, 0.14113622, -0.06657818, 0.13492396,
			0.03361964, -0.01538245, 0.00247246, -0.02268517, 0.01070127, -0.02168666,
			-0.30846516, 0.14113622, -0.02268517, 0.20813978, -0.09818576, 0.1989783,
			0.14551225, -0.06657818, 0.01070127, -0.09818576, 0.04631716, -0.09386402,
			-0.29488776, 0.13492396, -0.02168666, 0.1989783, -0.09386402, 0.19022007;


	result.setMeans(means);
	result.setRef(ref);
	result.setWeight(weight);
	result.setTrialNumbers({ NB_TRIALS1, NB_TRIALS2 });
	return result;
}

inline Geometry::CMatrixClassifierFgMDMRT AfterSupervised() { return Geometry::CMatrixClassifierFgMDMRT(NB_CLASS, Geometry::EMetric::Riemann); }
inline Geometry::CMatrixClassifierFgMDMRT AfterUnSupervised() { return Geometry::CMatrixClassifierFgMDMRT(NB_CLASS, Geometry::EMetric::Riemann); }
inline std::vector<size_t> Prediction() { return std::vector<size_t>{ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1 }; }
inline std::vector<size_t> PredictionSupervised() { return std::vector<size_t>{ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1 }; }
inline std::vector<size_t> PredictionUnSupervised() { return std::vector<size_t>{ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1 }; }

inline std::vector<std::vector<double>> PredictionDistance()
{
	std::vector<std::vector<double>> result(NB_TRIALS);
	result[0]  = { 0.02665352, 0.71870784 };
	result[1]  = { 0.0963665, 0.78842083 };
	result[2]  = { 0.27172762, 0.4203267 };
	result[3]  = { 0.86848167, 1.56053599 };
	result[4]  = { 0.13999143, 0.83204575 };
	result[5]  = { 0.44863838, 0.24341594 };
	result[6]  = { 0.41112711, 0.28092722 };
	result[7]  = { 0.59496729, 0.09708703 };
	result[8]  = { 0.87589215, 0.18383782 };
	result[9]  = { 0.76329856, 0.07124423 };
	result[10] = { 0.59422854, 0.09782578 };
	result[11] = { 0.63188509, 0.06016924 };
	return result;
}

inline std::vector<std::vector<double>> PredictionDistanceSupervised() { return std::vector<std::vector<double>>(NB_TRIALS, { 0, 0 }); }
inline std::vector<std::vector<double>> PredictionDistanceUnSupervised() { return std::vector<std::vector<double>>(NB_TRIALS, { 0, 0 }); }
}  // namespace FgMDMRT

namespace MDMRebias {
inline Geometry::CMatrixClassifierMDMRebias Reference()
{
	Geometry::CMatrixClassifierMDMRebias result(NB_CLASS, Geometry::EMetric::Riemann);
	std::vector<Eigen::MatrixXd> means(NB_CLASS, Eigen::MatrixXd(NB_CHAN, NB_CHAN));

	means[0] << 1.129204848898484, -0.103109478655884, -0.005579207794177,
			-0.103109478655884, 0.884890317836479, 0.015961516899074,
			-0.005579207794177, 0.015961516899074, 0.801503003117589;

	means[1] << 0.855588028031272, 0.146119935000422, 0.004175889722330,
			0.146119935000422, 1.212891172460091, -0.030535218161296,
			0.004175889722330, -0.030535218161296, 1.364418888484737;

	Geometry::CBias bias;
	bias.setClassificationNumber(0);
	Eigen::MatrixXd m(NB_CHAN, NB_CHAN);
	m << 1.709522177383279, 0.016735943232583, 0.020785623695383,
			0.016735943232582, 1.603446473585329, 0.054241640196169,
			0.020785623695383, 0.054241640196169, 0.830327834469631;
	bias.setBias(m);
	
	result.setMeans(means);
	result.setTrialNumbers({ NB_TRIALS1, NB_TRIALS2 });
	result.setBias(bias);
	return result;
}

inline Geometry::CMatrixClassifierMDMRebias After()
{
	Geometry::CMatrixClassifierMDMRebias result(NB_CLASS, Geometry::EMetric::Riemann);
	std::vector<Eigen::MatrixXd> means(NB_CLASS, Eigen::MatrixXd(NB_CHAN, NB_CHAN));

	means[0] << 1.129204848898484, -0.103109478655884, -0.005579207794177,
			-0.103109478655884, 0.884890317836479, 0.015961516899074,
			-0.005579207794177, 0.015961516899074, 0.801503003117589;

	means[1] << 0.855588028031272, 0.146119935000422, 0.004175889722330,
			0.146119935000422, 1.212891172460091, -0.030535218161296,
			0.004175889722330, -0.030535218161296, 1.364418888484737;

	Geometry::CBias bias;
	bias.setClassificationNumber(NB_TRIALS);
	Eigen::MatrixXd m(NB_CHAN, NB_CHAN);
	m << 1.705589799010000, 0.015745816879592, 0.019622109841865,
			0.015745816879592, 1.606186296382902, 0.055107313019667,
			0.019622109841864, 0.055107313019667, 0.830841812602058;
	bias.setBias(m);

	result.setMeans(means);
	result.setTrialNumbers({ NB_TRIALS1, NB_TRIALS2 });
	result.setBias(bias);
	return result;
}

inline Geometry::CMatrixClassifierMDMRebias AfterSupervised()
{
	Geometry::CMatrixClassifierMDMRebias result(NB_CLASS, Geometry::EMetric::Riemann);
	std::vector<Eigen::MatrixXd> means(NB_CLASS, Eigen::MatrixXd(NB_CHAN, NB_CHAN));

	means[0] << 1.077801701232086, -0.135609812697659, -0.032311282008452,
			-0.135609812697659, 0.947469327241560, -0.034394668642257,
			-0.032311282008452, -0.034394668642258, 0.986389056463633;

	means[1] << 0.846602361879856, 0.168419115431573, 0.000436175648620,
			0.168419115431572, 1.264667771319573, -0.037722396726046,
			0.000436175648620, -0.037722396726045, 1.474562819298618;

	Geometry::CBias bias;
	bias.setClassificationNumber(NB_TRIALS);
	Eigen::MatrixXd m(NB_CHAN, NB_CHAN);
	m << 1.705589799010000, 0.015745816879592, 0.019622109841865,
			0.015745816879592, 1.606186296382902, 0.055107313019667,
			0.019622109841864, 0.055107313019667, 0.830841812602058;
	bias.setBias(m);

	result.setMeans(means);
	result.setTrialNumbers({ 2 * NB_TRIALS1, 2 * NB_TRIALS2 });
	result.setBias(bias);
	return result;
}

inline Geometry::CMatrixClassifierMDMRebias AfterUnSupervised()
{
	Geometry::CMatrixClassifierMDMRebias result(NB_CLASS, Geometry::EMetric::Riemann);
	std::vector<Eigen::MatrixXd> means(NB_CLASS, Eigen::MatrixXd(NB_CHAN, NB_CHAN));

	means[0] << 1.163328386007378, -0.071528982784288, 0.003415904977547,
			-0.071528982784288, 0.865367469644902, 0.037539841921305,
			0.003415904977547, 0.037539841921304, 0.725209905616625;

	means[1] << 0.867551363970510, 0.027654580821275, -0.039319369201831,
			0.027654580821275, 1.192704425561919, -0.114920170106705,
			-0.039319369201831, -0.114920170106704, 1.554798562413437;

	Geometry::CBias bias;
	bias.setClassificationNumber(NB_TRIALS);
	Eigen::MatrixXd m(NB_CHAN, NB_CHAN);
	m << 1.705589799010000, 0.015745816879592, 0.019622109841865,
			0.015745816879592, 1.606186296382902, 0.055107313019667,
			0.019622109841864, 0.055107313019667, 0.830841812602058;
	bias.setBias(m);

	result.setMeans(means);
	result.setTrialNumbers({ NB_TRIALS1 + 2, NB_TRIALS2 + 10 });// Find 2 & 10 times in Prediction
	result.setBias(bias);
	return result;
}

inline std::vector<size_t> Prediction() { return std::vector<size_t>{ 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1 }; }
inline std::vector<size_t> PredictionSupervised() { return std::vector<size_t>{ 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1 }; }
inline std::vector<size_t> PredictionUnSupervised() { return std::vector<size_t>{ 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1 }; }

inline std::vector<std::vector<double>> PredictionDistance()
{
	std::vector<std::vector<double>> result(NB_TRIALS);
	result[0]  = { 1.314629453210112, 1.474855008515001 };
	result[1]  = { 1.695656381031027, 1.841285722807642 };
	result[2]  = { 0.985038237804275, 0.841748947395782 };
	result[3]  = { 0.893165255444375, 1.599278236985282 };
	result[4]  = { 0.999895116206910, 0.941884079636976 };
	result[5]  = { 1.137476666505600, 0.465758462215674 };
	result[6]  = { 1.011555978384045, 0.477398295992067 };
	result[7]  = { 1.061656174626915, 0.693427342482516 };
	result[8]  = { 1.170383892226384, 0.490874398142692 };
	result[9]  = { 1.264605170966096, 0.711483172971687 };
	result[10] = { 0.958316311213036, 0.443514577199302 };
	result[11] = { 0.979165666917157, 0.506488669219013 };
	return result;
}

inline std::vector<std::vector<double>> PredictionDistanceSupervised()
{
	std::vector<std::vector<double>> result(NB_TRIALS);
	result[0]  = { 1.314629453210112, 1.474855008515001 };
	result[1]  = { 1.855966579223177, 1.841285722807642 };
	result[2]  = { 0.958576739762368, 0.841748947395782 };
	result[3]  = { 0.923258071960562, 1.599278236985282 };
	result[4]  = { 0.972293627395511, 0.941884079636976 };
	result[5]  = { 1.081434198790791, 0.465758462215674 };
	result[6]  = { 0.886487914539492, 0.477398295992067 };
	result[7]  = { 1.019626392142984, 0.693427342482516 };
	result[8]  = { 1.065871792145533, 0.446604052630479 };
	result[9]  = { 1.069057512264309, 0.803506934337151 };
	result[10] = { 0.813748223596456, 0.477967335007498 };
	result[11] = { 0.768497985059151, 0.533247406413060 };
	return result;
}

inline std::vector<std::vector<double>> PredictionDistanceUnSupervised()
{
	std::vector<std::vector<double>> result(NB_TRIALS);
	result[0]  = { 1.314629453210112, 1.474855008515001 };
	result[1]  = { 1.855966579223177, 1.841285722807642 };
	result[2]  = { 1.077703693722418, 0.677588292749563 };
	result[3]  = { 0.990907763223969, 1.416399657557998 };
	result[4]  = { 1.102040763358186, 0.797780684168623 };
	result[5]  = { 1.233329154201637, 0.544647072527355 };
	result[6]  = { 1.103888150188716, 0.487000074621019 };
	result[7]  = { 1.094214879276997, 0.921591225768512 };
	result[8]  = { 1.223770999299696, 0.714324156664128 };
	result[9]  = { 1.357590792239233, 0.679090817494962 };
	result[10] = { 1.028663404532504, 0.505823409893398 };
	result[11] = { 1.085189723107800, 0.367393525001945 };
	return result;
}
}  // namespace MDMRebias

namespace FgMDM {
inline Geometry::CMatrixClassifierFgMDM Reference()
{
	Geometry::CMatrixClassifierFgMDM result(NB_CLASS, Geometry::EMetric::Riemann);
	std::vector<Eigen::MatrixXd> means(NB_CLASS, Eigen::MatrixXd(NB_CHAN, NB_CHAN));

	means[0] << 2.08042432, -0.08968098, 0.03145977,
			-0.08968098, 1.41163613, 0.09127538,
			0.03145977, 0.09127538, 0.734828;

	means[1] << 1.30840283, 0.15716713, 0.00232698,
			0.15716713, 1.93455782, -0.01963492,
			0.00232698, -0.01963492, 0.98852719;

	Eigen::MatrixXd ref(NB_CHAN, NB_CHAN);
	ref << 1.70952664, 0.01674082, 0.02077766,
			0.01674082, 1.60344581, 0.05423902,
			0.02077766, 0.05423902, 0.8303257;

	Eigen::MatrixXd weight = Eigen::MatrixXd(NB_FEATURES, NB_FEATURES);
	weight << 0.45714834, -0.20916523, 0.03361964, -0.30846516, 0.14551225, -0.29488776,
			-0.20916523, 0.09570218, -0.01538245, 0.14113622, -0.06657818, 0.13492396,
			0.03361964, -0.01538245, 0.00247246, -0.02268517, 0.01070127, -0.02168666,
			-0.30846516, 0.14113622, -0.02268517, 0.20813978, -0.09818576, 0.1989783,
			0.14551225, -0.06657818, 0.01070127, -0.09818576, 0.04631716, -0.09386402,
			-0.29488776, 0.13492396, -0.02168666, 0.1989783, -0.09386402, 0.19022007;

	result.setMeans(means);
	result.setRef(ref);
	result.setWeight(weight);
	result.setTrialNumbers({ NB_TRIALS1, NB_TRIALS2 });
	result.setDatasets(InitCovariance::LWF::Reference());
	return result;
}

inline Geometry::CMatrixClassifierFgMDM AfterSupervised() { return Geometry::CMatrixClassifierFgMDM(NB_CLASS, Geometry::EMetric::Riemann); }

inline Geometry::CMatrixClassifierFgMDM AfterUnSupervised() { return Geometry::CMatrixClassifierFgMDM(NB_CLASS, Geometry::EMetric::Riemann); }

inline std::vector<size_t> PredictionSupervised() { return std::vector<size_t>{ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1 }; }
inline std::vector<size_t> PredictionUnSupervised() { return std::vector<size_t>{ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1 }; }

inline std::vector<std::vector<double>> PredictionDistanceSupervised() { return std::vector<std::vector<double>>(NB_TRIALS, { 0, 0 }); }

inline std::vector<std::vector<double>> PredictionDistanceUnSupervised() { return std::vector<std::vector<double>>(NB_TRIALS, { 0, 0 }); }
}  // namespace FgMDM

namespace FgMDMRTRebias {
inline Geometry::CMatrixClassifierFgMDMRTRebias Reference()
{
	Geometry::CMatrixClassifierFgMDMRTRebias result(NB_CLASS, Geometry::EMetric::Riemann);
	std::vector<Eigen::MatrixXd> means(NB_CLASS, Eigen::MatrixXd(NB_CHAN, NB_CHAN));

	means[0] << 1.21749102419878, -0.065244040475294, 0.00919064364644959,
			-0.0652440404752944, 0.879520180058735, 0.0383106920991925,
			0.00919064364644961, 0.0383106920991925, 0.882712321945327;

	means[1] << 0.764724285777722, 0.0858374005624361, -0.0164757238732658,
			0.0858374005624357, 1.20857271214632, -0.0743441311282506,
			-0.0164757238732657, -0.0743441311282506, 1.19491180388651;

	const Eigen::MatrixXd ref = Eigen::MatrixXd::Identity(NB_CHAN, NB_CHAN);
	Eigen::MatrixXd weight    = Eigen::MatrixXd(NB_FEATURES, NB_FEATURES);
	weight << 0.457148328143448, -0.209165242331525, 0.0336196848430174, -0.308465155960592, 0.145512230780716, -0.294887759430561,
			-0.209165242331525, 0.0957021953405835, -0.0153824679964544, 0.141136224558352, -0.0665781741717288, 0.134923975140382,
			0.0336196848430174, -0.0153824679964544, 0.00247246492956471, -0.0226852001637271, 0.0107012867344819, -0.0216866888180067,
			-0.308465155960592, 0.141136224558352, -0.0226852001637271, 0.208139779988291, -0.098185753285447, 0.19897830332888,
			0.145512230780716, -0.0665781741717288, 0.0107012867344819, -0.098185753285447, 0.0463171535435127, -0.0938640110069554,
			-0.294887759430561, 0.134923975140382, -0.0216866888180067, 0.19897830332888, -0.0938640110069554, 0.190220078054599;

	Geometry::CBias bias;
	bias.setClassificationNumber(0);
	Eigen::MatrixXd m(NB_CHAN, NB_CHAN);
	m << 1.70952703700155, 0.0167406580855047, 0.0207774590925802,
			0.0167406580855047, 1.60344585621418, 0.0542388460600326,
			0.0207774590925802, 0.0542388460600327, 0.830325461380695;
	bias.setBias(m);

	result.setMeans(means);
	result.setRef(ref);
	result.setWeight(weight);
	result.setTrialNumbers({ NB_TRIALS1, NB_TRIALS2 });
	result.setBias(bias);
	return result;
}

inline Geometry::CMatrixClassifierFgMDMRTRebias After()
{
	Geometry::CMatrixClassifierFgMDMRTRebias result(NB_CLASS, Geometry::EMetric::Riemann);
	std::vector<Eigen::MatrixXd> means(NB_CLASS, Eigen::MatrixXd(NB_CHAN, NB_CHAN));

	means[0] << 2.08042432, -0.08968098, 0.03145977,
			-0.08968098, 1.41163613, 0.09127538,
			0.03145977, 0.09127538, 0.734828;

	means[1] << 1.30840283, 0.15716713, 0.00232698,
			0.15716713, 1.93455782, -0.01963492,
			0.00232698, -0.01963492, 0.98852719;

	Eigen::MatrixXd ref(NB_CHAN, NB_CHAN);
	ref << 1.70952664, 0.01674082, 0.02077766,
			0.01674082, 1.60344581, 0.05423902,
			0.02077766, 0.05423902, 0.8303257;

	Eigen::MatrixXd weight = Eigen::MatrixXd(NB_FEATURES, NB_FEATURES);
	weight << 0.45714834, -0.20916523, 0.03361964, -0.30846516, 0.14551225, -0.29488776,
			-0.20916523, 0.09570218, -0.01538245, 0.14113622, -0.06657818, 0.13492396,
			0.03361964, -0.01538245, 0.00247246, -0.02268517, 0.01070127, -0.02168666,
			-0.30846516, 0.14113622, -0.02268517, 0.20813978, -0.09818576, 0.1989783,
			0.14551225, -0.06657818, 0.01070127, -0.09818576, 0.04631716, -0.09386402,
			-0.29488776, 0.13492396, -0.02168666, 0.1989783, -0.09386402, 0.19022007;

	Geometry::CBias bias;
	bias.setClassificationNumber(0);
	Eigen::MatrixXd m(NB_CHAN, NB_CHAN);
	m << 1.709522177383279, 0.016735943232583, 0.020785623695383,
			0.016735943232582, 1.603446473585329, 0.054241640196169,
			0.020785623695383, 0.054241640196169, 0.830327834469631;
	bias.setBias(m);

	result.setMeans(means);
	result.setRef(ref);
	result.setWeight(weight);
	result.setTrialNumbers({ NB_TRIALS1, NB_TRIALS2 });
	result.setBias(bias);
	return result;
}

inline Geometry::CMatrixClassifierFgMDMRTRebias AfterSupervised()
{
	Geometry::CMatrixClassifierFgMDMRTRebias result(NB_CLASS, Geometry::EMetric::Riemann);
	const std::vector<Eigen::MatrixXd> means(NB_CLASS, Eigen::MatrixXd::Zero(NB_CHAN, NB_CHAN));
	const Eigen::MatrixXd ref    = Eigen::MatrixXd::Zero(NB_CHAN, NB_CHAN);
	const Eigen::MatrixXd weight = Eigen::MatrixXd::Zero(NB_FEATURES, NB_FEATURES);

	Geometry::CBias bias;
	bias.setClassificationNumber(0);
	const Eigen::MatrixXd m = Eigen::MatrixXd::Zero(NB_CHAN, NB_CHAN);
	bias.setBias(m);

	result.setMeans(means);
	result.setRef(ref);
	result.setWeight(weight);
	result.setTrialNumbers({ NB_TRIALS1, NB_TRIALS2 });
	result.setBias(bias);
	return result;
}

inline Geometry::CMatrixClassifierFgMDMRTRebias AfterUnSupervised()
{
	Geometry::CMatrixClassifierFgMDMRTRebias result(NB_CLASS, Geometry::EMetric::Riemann);
	const std::vector<Eigen::MatrixXd> means(NB_CLASS, Eigen::MatrixXd::Zero(NB_CHAN, NB_CHAN));
	const Eigen::MatrixXd ref    = Eigen::MatrixXd::Zero(NB_CHAN, NB_CHAN);
	const Eigen::MatrixXd weight = Eigen::MatrixXd::Zero(NB_FEATURES, NB_FEATURES);

	Geometry::CBias bias;
	bias.setClassificationNumber(0);
	const Eigen::MatrixXd m = Eigen::MatrixXd::Zero(NB_CHAN, NB_CHAN);
	bias.setBias(m);

	result.setMeans(means);
	result.setRef(ref);
	result.setWeight(weight);
	result.setTrialNumbers({ NB_TRIALS1, NB_TRIALS2 });
	result.setBias(bias);
	return result;
}

inline std::vector<size_t> Prediction() { return std::vector<size_t>{ 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1 }; }
inline std::vector<size_t> PredictionSupervised() { return std::vector<size_t>{ 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1 }; }
inline std::vector<size_t> PredictionUnSupervised() { return std::vector<size_t>{ 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1 }; }

inline std::vector<std::vector<double>> PredictionDistance()
{
	std::vector<std::vector<double>> result(NB_TRIALS);
	result[0]  = { 0.02665352, 0.71870784 };
	result[1]  = { 0.0963665, 0.78842083 };
	result[2]  = { 0.27172762, 0.4203267 };
	result[3]  = { 0.86848167, 1.56053599 };
	result[4]  = { 0.13999143, 0.83204575 };
	result[5]  = { 0.44863838, 0.24341594 };
	result[6]  = { 0.41112711, 0.28092722 };
	result[7]  = { 0.59496729, 0.09708703 };
	result[8]  = { 0.87589215, 0.18383782 };
	result[9]  = { 0.76329856, 0.07124423 };
	result[10] = { 0.59422854, 0.09782578 };
	result[11] = { 0.63188509, 0.06016924 };
	return result;
}

inline std::vector<std::vector<double>> PredictionDistanceSupervised() { return std::vector<std::vector<double>>(NB_TRIALS, { 0, 0 }); }
inline std::vector<std::vector<double>> PredictionDistanceUnSupervised() { return std::vector<std::vector<double>>(NB_TRIALS, { 0, 0 }); }
}  // namespace FgMDMRTRebias
}  // namespace InitMatrixClassif
