<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Riemann Geometrie: Geometry Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Riemann Geometrie
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Geometry Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geometry_1_1_c_a_s_r.html">CASR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class For Artifact Subspace Reconstruction (ASR) Algorithm.  <a href="class_geometry_1_1_c_a_s_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geometry_1_1_c_bias.html">CBias</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class For Bias Algorithm for covariance matrices.  <a href="class_geometry_1_1_c_bias.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geometry_1_1_c_matrix_classifier_fg_m_d_m.html">CMatrixClassifierFgMDM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of Minimum Distance to Mean with geodesic filtering (FgMDM) Classifier.  <a href="class_geometry_1_1_c_matrix_classifier_fg_m_d_m.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geometry_1_1_c_matrix_classifier_fg_m_d_m_r_t.html">CMatrixClassifierFgMDMRT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of Minimum Distance to Mean with geodesic filtering (FgMDM) Classifier RT (adaptation is Real Time Assumed).  <a href="class_geometry_1_1_c_matrix_classifier_fg_m_d_m_r_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geometry_1_1_c_matrix_classifier_fg_m_d_m_r_t_rebias.html">CMatrixClassifierFgMDMRTRebias</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of Minimum Distance to Mean with geodesic filtering (FgMDM) Classifier RT (adaptation is Real Time Assumed).  <a href="class_geometry_1_1_c_matrix_classifier_fg_m_d_m_r_t_rebias.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geometry_1_1_c_matrix_classifier_m_d_m.html">CMatrixClassifierMDM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of Minimum Distance to Mean (MDM) Classifier.  <a href="class_geometry_1_1_c_matrix_classifier_m_d_m.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geometry_1_1_c_matrix_classifier_m_d_m_rebias.html">CMatrixClassifierMDMRebias</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class of Minimum Distance to Mean (MDM) Classifier with Rebias.  <a href="class_geometry_1_1_c_matrix_classifier_m_d_m_rebias.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_geometry_1_1_i_matrix_classifier.html">IMatrixClassifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class of Matrix Classifier.  <a href="class_geometry_1_1_i_matrix_classifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a523d040f5c68154ee9e6647768d26841"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a523d040f5c68154ee9e6647768d26841">EStandardization</a> { <a class="el" href="namespace_geometry.html#a523d040f5c68154ee9e6647768d26841a6adf97f83acf6453d4a6a4b1070f3754">EStandardization::None</a>, 
<a class="el" href="namespace_geometry.html#a523d040f5c68154ee9e6647768d26841a4f1f6016fc9f3f2353c0cc7c67b292bd">EStandardization::Center</a>, 
<a class="el" href="namespace_geometry.html#a523d040f5c68154ee9e6647768d26841af93d9c0bb5d4d92fcc4a807b97d32aa6">EStandardization::StandardScale</a>
 }<tr class="memdesc:a523d040f5c68154ee9e6647768d26841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of Standardization method for features matrix data.  <a href="namespace_geometry.html#a523d040f5c68154ee9e6647768d26841">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a523d040f5c68154ee9e6647768d26841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55ab4136356f33e78b9ec964767f29a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#ac55ab4136356f33e78b9ec964767f29a">EAdaptations</a> { <a class="el" href="namespace_geometry.html#ac55ab4136356f33e78b9ec964767f29aa6adf97f83acf6453d4a6a4b1070f3754">EAdaptations::None</a>, 
<a class="el" href="namespace_geometry.html#ac55ab4136356f33e78b9ec964767f29aa1e67d6601e5c4a80ece61d4516427413">EAdaptations::Supervised</a>, 
<a class="el" href="namespace_geometry.html#ac55ab4136356f33e78b9ec964767f29aaeef6d82d4789990b23260ed94f46fa59">EAdaptations::Unsupervised</a>
 }<tr class="memdesc:ac55ab4136356f33e78b9ec964767f29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of Adaptation Methods for classifier.  <a href="namespace_geometry.html#ac55ab4136356f33e78b9ec964767f29a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac55ab4136356f33e78b9ec964767f29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41128205b080c60f7031983dd6cab9a5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a41128205b080c60f7031983dd6cab9a5">EMatrixClassifiers</a> { <br />
&#160;&#160;<a class="el" href="namespace_geometry.html#a41128205b080c60f7031983dd6cab9a5a1044ebd2843c1a9c4b9900135e706ba8">EMatrixClassifiers::MDM</a>, 
<a class="el" href="namespace_geometry.html#a41128205b080c60f7031983dd6cab9a5a8fee10fd5c03e074d9faf9a72724b6d5">EMatrixClassifiers::MDM_Rebias</a>, 
<a class="el" href="namespace_geometry.html#a41128205b080c60f7031983dd6cab9a5afde1ff9fb859e6eef3ebf11548d7b593">EMatrixClassifiers::FgMDM_RT</a>, 
<a class="el" href="namespace_geometry.html#a41128205b080c60f7031983dd6cab9a5aadfbeada02d2a3dca176b4a7ff8cf1ca">EMatrixClassifiers::FgMDM</a>, 
<br />
&#160;&#160;<a class="el" href="namespace_geometry.html#a41128205b080c60f7031983dd6cab9a5a3fb59b48e2ac69b5218063d27ae32704">EMatrixClassifiers::FgMDM_RT_Rebias</a>, 
<a class="el" href="namespace_geometry.html#a41128205b080c60f7031983dd6cab9a5ab49f68275acaafa375565eecb66eddaf">EMatrixClassifiers::FgMDM_Rebias</a>
<br />
 }<tr class="memdesc:a41128205b080c60f7031983dd6cab9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><hr/>
  <a href="namespace_geometry.html#a41128205b080c60f7031983dd6cab9a5">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a41128205b080c60f7031983dd6cab9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5f0ced7932cbe299c3631735d6e9e9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9">EEstimator</a> { <br />
&#160;&#160;<a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9a18448d7ac6e52fa9f9bb5861b0397b6e">EEstimator::COV</a>, 
<a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9a616842b667c02164dda634d846884093">EEstimator::SCM</a>, 
<a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9a19d4dcda54d9547a1195d4c793347219">EEstimator::LWF</a>, 
<a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9aed16caa1a3469c82adfa26a6583ec15b">EEstimator::OAS</a>, 
<br />
&#160;&#160;<a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9a23d8bc2b33aa76cd40f661c9e181ef67">EEstimator::MCD</a>, 
<a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9ae928eee5ddbc4bf948a87749f9365980">EEstimator::COR</a>, 
<a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9a581d6381f3f35e4f9d77201acf87b364">EEstimator::IDE</a>
<br />
 }<tr class="memdesc:abc5f0ced7932cbe299c3631735d6e9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the covariance matrix estimator. Inspired by the work of Alexandre Barachant : <a href="https://github.com/alexandrebarachant/pyRiemann">pyRiemann</a>.  <a href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:abc5f0ced7932cbe299c3631735d6e9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b2f142b97d4b99fa2327f29b9c5bf5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5">EMetric</a> { <br />
&#160;&#160;<a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5a61ea1974dd974297913b1fa2f0470d26">EMetric::Riemann</a>, 
<a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5aedca8775d78e240ca6902e89c60621bb">EMetric::Euclidian</a>, 
<a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5a2a1dfc1bc7b79fc5f5ee51e8e6ef1f95">EMetric::LogEuclidian</a>, 
<a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5a981ef655132b1c498b56608510008cba">EMetric::LogDet</a>, 
<br />
&#160;&#160;<a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5a9ed1095d5cb5285b113fd9be6ca03f6c">EMetric::Kullback</a>, 
<a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5a8785d2665b38ccc078c7086609c6a931">EMetric::ALE</a>, 
<a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5a9a0b88b2920076082bc28d827b18d9fb">EMetric::Harmonic</a>, 
<a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5af55d2253af03ad9dd88c01a3c3670fbc">EMetric::Wasserstein</a>, 
<br />
&#160;&#160;<a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5ac9c5c65fb4af9cf90eb99b3b84424189">EMetric::Identity</a>
<br />
 }<tr class="memdesc:ae7b2f142b97d4b99fa2327f29b9c5bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of metrics. Inspired by the work of Alexandre Barachant : <a href="https://github.com/alexandrebarachant/pyRiemann">pyRiemann</a>.  <a href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ae7b2f142b97d4b99fa2327f29b9c5bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa36b39703f6c8ffe82046b27ec9deb91"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#aa36b39703f6c8ffe82046b27ec9deb91">AffineTransformation</a> (const Eigen::MatrixXd &amp;ref, const Eigen::MatrixXd &amp;matrix)</td></tr>
<tr class="memdesc:aa36b39703f6c8ffe82046b27ec9deb91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an affine transformation and return the result (The last transpose is useless if matrix is SPD). </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ B = R^{-1/2} * A * {R^{-1/2}}^{\mathsf{T}} \]" src="form_0.png"/>
</p>
  <a href="#aa36b39703f6c8ffe82046b27ec9deb91">More...</a><br /></td></tr>
<tr class="separator:aa36b39703f6c8ffe82046b27ec9deb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21026f164262c111902f3bd7de7e4222"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a21026f164262c111902f3bd7de7e4222">MatrixStandardization</a> (Eigen::MatrixXd &amp;matrix, <a class="el" href="namespace_geometry.html#a523d040f5c68154ee9e6647768d26841">EStandardization</a> standard=<a class="el" href="namespace_geometry.html#a523d040f5c68154ee9e6647768d26841a6adf97f83acf6453d4a6a4b1070f3754">EStandardization::None</a>)</td></tr>
<tr class="memdesc:a21026f164262c111902f3bd7de7e4222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standardize data row by row with selected method (destructive operation).  <a href="#a21026f164262c111902f3bd7de7e4222">More...</a><br /></td></tr>
<tr class="separator:a21026f164262c111902f3bd7de7e4222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822bff91b5d2d1e41bf6e29552b72b12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a822bff91b5d2d1e41bf6e29552b72b12">MatrixStandardization</a> (const Eigen::MatrixXd &amp;in, Eigen::MatrixXd &amp;out, <a class="el" href="namespace_geometry.html#a523d040f5c68154ee9e6647768d26841">EStandardization</a> standard=<a class="el" href="namespace_geometry.html#a523d040f5c68154ee9e6647768d26841a6adf97f83acf6453d4a6a4b1070f3754">EStandardization::None</a>)</td></tr>
<tr class="memdesc:a822bff91b5d2d1e41bf6e29552b72b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standardize data row by row with selected method (non destructive operation).  <a href="#a822bff91b5d2d1e41bf6e29552b72b12">More...</a><br /></td></tr>
<tr class="separator:a822bff91b5d2d1e41bf6e29552b72b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ca5a71291053eafff937512072328a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a03ca5a71291053eafff937512072328a">MatrixCenter</a> (Eigen::MatrixXd &amp;matrix)</td></tr>
<tr class="memdesc:a03ca5a71291053eafff937512072328a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the mean of each row at the matrix (destructive operation).<br />
So <img class="formulaInl" alt="$\mu=0$" src="form_1.png"/>.  <a href="#a03ca5a71291053eafff937512072328a">More...</a><br /></td></tr>
<tr class="separator:a03ca5a71291053eafff937512072328a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde10cd924c56e050900d8d8967a44ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#afde10cd924c56e050900d8d8967a44ae">MatrixCenter</a> (const Eigen::MatrixXd &amp;in, Eigen::MatrixXd &amp;out)</td></tr>
<tr class="memdesc:afde10cd924c56e050900d8d8967a44ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the mean of each row at the matrix (non destructive operation).<br />
So <img class="formulaInl" alt="$\mu=0$" src="form_1.png"/>.  <a href="#afde10cd924c56e050900d8d8967a44ae">More...</a><br /></td></tr>
<tr class="separator:afde10cd924c56e050900d8d8967a44ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae67252afea0dc9ee1751460660b83d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#abae67252afea0dc9ee1751460660b83d">MatrixStandardScaler</a> (Eigen::MatrixXd &amp;matrix, Eigen::RowVectorXd &amp;scale)</td></tr>
<tr class="memdesc:abae67252afea0dc9ee1751460660b83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the mean of each row at the matrix and divide by the variance (destructive operation with scale return).<br />
So <img class="formulaInl" alt="$\mu=0$" src="form_1.png"/> and <img class="formulaInl" alt="$\sigma=1$" src="form_2.png"/>.  <a href="#abae67252afea0dc9ee1751460660b83d">More...</a><br /></td></tr>
<tr class="separator:abae67252afea0dc9ee1751460660b83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe288564e75be68b6ed689a602de6b1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#abe288564e75be68b6ed689a602de6b1d">MatrixStandardScaler</a> (Eigen::MatrixXd &amp;matrix)</td></tr>
<tr class="memdesc:abe288564e75be68b6ed689a602de6b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the mean of each row at the matrix and divide by the variance (destructive operation).<br />
So <img class="formulaInl" alt="$\mu=0$" src="form_1.png"/> and <img class="formulaInl" alt="$\sigma=1$" src="form_2.png"/>.  <a href="#abe288564e75be68b6ed689a602de6b1d">More...</a><br /></td></tr>
<tr class="separator:abe288564e75be68b6ed689a602de6b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484f6f740b108fb7929fd5fa3fe59d1c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a484f6f740b108fb7929fd5fa3fe59d1c">MatrixStandardScaler</a> (const Eigen::MatrixXd &amp;in, Eigen::MatrixXd &amp;out, Eigen::RowVectorXd &amp;scale)</td></tr>
<tr class="memdesc:a484f6f740b108fb7929fd5fa3fe59d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the mean of each row at the matrix and divide by the variance (non destructive operation with scale return).<br />
So <img class="formulaInl" alt="$\mu=0$" src="form_1.png"/> and <img class="formulaInl" alt="$\sigma=1$" src="form_2.png"/>.  <a href="#a484f6f740b108fb7929fd5fa3fe59d1c">More...</a><br /></td></tr>
<tr class="separator:a484f6f740b108fb7929fd5fa3fe59d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e78afbb2bda9aebc6c63eb685ebd19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a53e78afbb2bda9aebc6c63eb685ebd19">MatrixStandardScaler</a> (const Eigen::MatrixXd &amp;in, Eigen::MatrixXd &amp;out)</td></tr>
<tr class="memdesc:a53e78afbb2bda9aebc6c63eb685ebd19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the mean of each row at the matrix and divide by the variance (non destructive operation).<br />
So <img class="formulaInl" alt="$\mu=0$" src="form_1.png"/> and <img class="formulaInl" alt="$\sigma=1$" src="form_2.png"/>.  <a href="#a53e78afbb2bda9aebc6c63eb685ebd19">More...</a><br /></td></tr>
<tr class="separator:a53e78afbb2bda9aebc6c63eb685ebd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7bc24b1b6807aef5a10d0a4c2e78e9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#aef7bc24b1b6807aef5a10d0a4c2e78e9">MatrixPrint</a> (const Eigen::MatrixXd &amp;matrix)</td></tr>
<tr class="memdesc:aef7bc24b1b6807aef5a10d0a4c2e78e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the string format of Matrix.  <a href="#aef7bc24b1b6807aef5a10d0a4c2e78e9">More...</a><br /></td></tr>
<tr class="separator:aef7bc24b1b6807aef5a10d0a4c2e78e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5c8b84af4038a25a249c5d99f21228"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a1f5c8b84af4038a25a249c5d99f21228">AreEquals</a> (const Eigen::MatrixXd &amp;matrix1, const Eigen::MatrixXd &amp;matrix2, double precision=1e-6)</td></tr>
<tr class="memdesc:a1f5c8b84af4038a25a249c5d99f21228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check first the size, then if not empty matrix and then if they are almost equal.  <a href="#a1f5c8b84af4038a25a249c5d99f21228">More...</a><br /></td></tr>
<tr class="separator:a1f5c8b84af4038a25a249c5d99f21228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1790223ebc2517a6dd2a6125648e7911"><td class="memItemLeft" align="right" valign="top">Eigen::RowVectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a1790223ebc2517a6dd2a6125648e7911">GetElements</a> (const Eigen::RowVectorXd &amp;row, const std::vector&lt; size_t &gt; &amp;index)</td></tr>
<tr class="memdesc:a1790223ebc2517a6dd2a6125648e7911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the items selected by the index.  <a href="#a1790223ebc2517a6dd2a6125648e7911">More...</a><br /></td></tr>
<tr class="separator:a1790223ebc2517a6dd2a6125648e7911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3167dfb6e8b2231624863605db9ba1de"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </td></tr>
<tr class="memitem:a3167dfb6e8b2231624863605db9ba1de"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a3167dfb6e8b2231624863605db9ba1de">ARange</a> (const T start, const T stop, const T step=1)</td></tr>
<tr class="memdesc:a3167dfb6e8b2231624863605db9ba1de"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a href="https://numpy.org/doc/stable/reference/generated/numpy.arange.html">Numpy arange</a> implementation in C++.  <a href="#a3167dfb6e8b2231624863605db9ba1de">More...</a><br /></td></tr>
<tr class="separator:a3167dfb6e8b2231624863605db9ba1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a37063547677cd920a80025da46634"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af5a37063547677cd920a80025da46634"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#af5a37063547677cd920a80025da46634">Vector2DTo1D</a> (const std::vector&lt; std::vector&lt; T &gt;&gt; &amp;in)</td></tr>
<tr class="memdesc:af5a37063547677cd920a80025da46634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn vector of vector into vector.  <a href="#af5a37063547677cd920a80025da46634">More...</a><br /></td></tr>
<tr class="separator:af5a37063547677cd920a80025da46634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0243494a4064279207a0484869dc1364"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0243494a4064279207a0484869dc1364"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a0243494a4064279207a0484869dc1364">Vector1DTo2D</a> (const std::vector&lt; T &gt; &amp;in, const std::vector&lt; size_t &gt; &amp;position)</td></tr>
<tr class="memdesc:a0243494a4064279207a0484869dc1364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn vector into vector of vector with position repartition.  <a href="#a0243494a4064279207a0484869dc1364">More...</a><br /></td></tr>
<tr class="separator:a0243494a4064279207a0484869dc1364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3b63720382fdec12165aab53b0cefd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a4e3b63720382fdec12165aab53b0cefd">InRange</a> (const double value, const double min, const double max)</td></tr>
<tr class="memdesc:a4e3b63720382fdec12165aab53b0cefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate if value is in [min;max].  <a href="#a4e3b63720382fdec12165aab53b0cefd">More...</a><br /></td></tr>
<tr class="separator:a4e3b63720382fdec12165aab53b0cefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f266f0c56237ac3202d6047849c1ee3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a5f266f0c56237ac3202d6047849c1ee3">AreNotEmpty</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;matrices)</td></tr>
<tr class="memdesc:a5f266f0c56237ac3202d6047849c1ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate if the vector is not empty and the matrices are validate.  <a href="#a5f266f0c56237ac3202d6047849c1ee3">More...</a><br /></td></tr>
<tr class="separator:a5f266f0c56237ac3202d6047849c1ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72070c0b521b34cd06132319e29e5e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#ab72070c0b521b34cd06132319e29e5e4">IsNotEmpty</a> (const Eigen::MatrixXd &amp;matrix)</td></tr>
<tr class="memdesc:ab72070c0b521b34cd06132319e29e5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates if matrix is not empty.  <a href="#ab72070c0b521b34cd06132319e29e5e4">More...</a><br /></td></tr>
<tr class="separator:ab72070c0b521b34cd06132319e29e5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa271733266d4835c65c91ec6ba43cf8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#aa271733266d4835c65c91ec6ba43cf8c">HaveSameSize</a> (const Eigen::MatrixXd &amp;a, const Eigen::MatrixXd &amp;b)</td></tr>
<tr class="memdesc:aa271733266d4835c65c91ec6ba43cf8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates if two matrix have same size.  <a href="#aa271733266d4835c65c91ec6ba43cf8c">More...</a><br /></td></tr>
<tr class="separator:aa271733266d4835c65c91ec6ba43cf8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97072006bdb184db6a3a34fd07a6e2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#ab97072006bdb184db6a3a34fd07a6e2f">HaveSameSize</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;matrices)</td></tr>
<tr class="memdesc:ab97072006bdb184db6a3a34fd07a6e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate if the vector is not empty and the matrices have same size.  <a href="#ab97072006bdb184db6a3a34fd07a6e2f">More...</a><br /></td></tr>
<tr class="separator:ab97072006bdb184db6a3a34fd07a6e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ff7acbbbafd70cbd42a6c3bbf4b088"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#ac9ff7acbbbafd70cbd42a6c3bbf4b088">IsSquare</a> (const Eigen::MatrixXd &amp;matrix)</td></tr>
<tr class="memdesc:ac9ff7acbbbafd70cbd42a6c3bbf4b088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates if matrix is square matrix and not empty.  <a href="#ac9ff7acbbbafd70cbd42a6c3bbf4b088">More...</a><br /></td></tr>
<tr class="separator:ac9ff7acbbbafd70cbd42a6c3bbf4b088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a48b66c4893ef1ac93d994ed6c9f33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#ae0a48b66c4893ef1ac93d994ed6c9f33">AreSquare</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;matrices)</td></tr>
<tr class="memdesc:ae0a48b66c4893ef1ac93d994ed6c9f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate if the vector is not empty and the matrices are square matrix and not empty.  <a href="#ae0a48b66c4893ef1ac93d994ed6c9f33">More...</a><br /></td></tr>
<tr class="separator:ae0a48b66c4893ef1ac93d994ed6c9f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7529f337a4e676a3eb3d76bcfc389bdf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a7529f337a4e676a3eb3d76bcfc389bdf">Split</a> (const std::string &amp;s, const std::string &amp;sep)</td></tr>
<tr class="memdesc:a7529f337a4e676a3eb3d76bcfc389bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the string split by the <code>sep</code> parameter.  <a href="#a7529f337a4e676a3eb3d76bcfc389bdf">More...</a><br /></td></tr>
<tr class="separator:a7529f337a4e676a3eb3d76bcfc389bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abe51bb1f564f1d2004115f7e428ed9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a5abe51bb1f564f1d2004115f7e428ed9">LSQR</a> (const std::vector&lt; std::vector&lt; Eigen::RowVectorXd &gt;&gt; &amp;datasets, Eigen::MatrixXd &amp;weight)</td></tr>
<tr class="memdesc:a5abe51bb1f564f1d2004115f7e428ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the weight of Linear Discriminant Analysis with Least squares (LSQR) Solver.  <a href="#a5abe51bb1f564f1d2004115f7e428ed9">More...</a><br /></td></tr>
<tr class="separator:a5abe51bb1f564f1d2004115f7e428ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a23032aa1f2ef3efa9a93f079952362"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a1a23032aa1f2ef3efa9a93f079952362">FgDACompute</a> (const std::vector&lt; std::vector&lt; Eigen::RowVectorXd &gt;&gt; &amp;datasets, Eigen::MatrixXd &amp;weight)</td></tr>
<tr class="memdesc:a1a23032aa1f2ef3efa9a93f079952362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Least squares (LSQR) Weight and transform to FgDA Weight. <br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ W_{\text{FgDA}} = W^{\mathsf{T}} \times (W \times W^{\mathsf{T}})^{-1} \times W \]" src="form_3.png"/>
</p>
  <a href="#a1a23032aa1f2ef3efa9a93f079952362">More...</a><br /></td></tr>
<tr class="separator:a1a23032aa1f2ef3efa9a93f079952362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4cd0253cdf114b5cd67e2db5e65f70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a7a4cd0253cdf114b5cd67e2db5e65f70">FgDAApply</a> (const Eigen::RowVectorXd &amp;in, Eigen::RowVectorXd &amp;out, const Eigen::MatrixXd &amp;weight)</td></tr>
<tr class="memdesc:a7a4cd0253cdf114b5cd67e2db5e65f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the weight on the vector. (just a matrix product)  <a href="#a7a4cd0253cdf114b5cd67e2db5e65f70">More...</a><br /></td></tr>
<tr class="separator:a7a4cd0253cdf114b5cd67e2db5e65f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416ad1cc4a49ee932341656dbde006c7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a416ad1cc4a49ee932341656dbde006c7">toString</a> (const <a class="el" href="namespace_geometry.html#ac55ab4136356f33e78b9ec964767f29a">EAdaptations</a> type)</td></tr>
<tr class="memdesc:a416ad1cc4a49ee932341656dbde006c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert adaptations to string.  <a href="#a416ad1cc4a49ee932341656dbde006c7">More...</a><br /></td></tr>
<tr class="separator:a416ad1cc4a49ee932341656dbde006c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089775c8f69783a27a056cf0dc28b749"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_geometry.html#ac55ab4136356f33e78b9ec964767f29a">EAdaptations</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a089775c8f69783a27a056cf0dc28b749">StringToAdaptation</a> (const std::string &amp;type)</td></tr>
<tr class="memdesc:a089775c8f69783a27a056cf0dc28b749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to adaptations.  <a href="#a089775c8f69783a27a056cf0dc28b749">More...</a><br /></td></tr>
<tr class="separator:a089775c8f69783a27a056cf0dc28b749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af784546f257d3f1ce6f6b4eb3b96b466"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#af784546f257d3f1ce6f6b4eb3b96b466">toString</a> (const <a class="el" href="namespace_geometry.html#a41128205b080c60f7031983dd6cab9a5">EMatrixClassifiers</a> type)</td></tr>
<tr class="memdesc:af784546f257d3f1ce6f6b4eb3b96b466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Matrix Classifiers to string.  <a href="#af784546f257d3f1ce6f6b4eb3b96b466">More...</a><br /></td></tr>
<tr class="separator:af784546f257d3f1ce6f6b4eb3b96b466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf8bad224ae9cd9a28a604716823cdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_geometry.html#a41128205b080c60f7031983dd6cab9a5">EMatrixClassifiers</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#abbf8bad224ae9cd9a28a604716823cdb">StringToMatrixClassifier</a> (const std::string &amp;type)</td></tr>
<tr class="memdesc:abbf8bad224ae9cd9a28a604716823cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to Matrix Classifiers.  <a href="#abbf8bad224ae9cd9a28a604716823cdb">More...</a><br /></td></tr>
<tr class="separator:abbf8bad224ae9cd9a28a604716823cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934bd571b9ec83389ad5bd5cc2fa53bc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a934bd571b9ec83389ad5bd5cc2fa53bc">toString</a> (const <a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9">EEstimator</a> estimator)</td></tr>
<tr class="memdesc:a934bd571b9ec83389ad5bd5cc2fa53bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert estimators to string.  <a href="#a934bd571b9ec83389ad5bd5cc2fa53bc">More...</a><br /></td></tr>
<tr class="separator:a934bd571b9ec83389ad5bd5cc2fa53bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed5d3175454a36e51fe88e3f1c1a74a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9">EEstimator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a4ed5d3175454a36e51fe88e3f1c1a74a">StringToEstimator</a> (const std::string &amp;estimator)</td></tr>
<tr class="memdesc:a4ed5d3175454a36e51fe88e3f1c1a74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to estimators.  <a href="#a4ed5d3175454a36e51fe88e3f1c1a74a">More...</a><br /></td></tr>
<tr class="separator:a4ed5d3175454a36e51fe88e3f1c1a74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b0a15045364dad7728f02677c1051c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a91b0a15045364dad7728f02677c1051c">Variance</a> (const Eigen::RowVectorXd &amp;x)</td></tr>
<tr class="memdesc:a91b0a15045364dad7728f02677c1051c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the Variance of a double dataset <img class="formulaInl" alt="$\vec{X}$" src="form_18.png"/>.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ V(X) = \left(\frac{1}{n} \sum_{i=1}^{N}x_{i}^{2}\right) - \left(\frac{1}{n} \sum_{i=1}^{N}x_{i}\right)^{2} \]" src="form_19.png"/>
</p>
  <a href="#a91b0a15045364dad7728f02677c1051c">More...</a><br /></td></tr>
<tr class="separator:a91b0a15045364dad7728f02677c1051c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bef1676f0081a698038a646f8bcdfb5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a2bef1676f0081a698038a646f8bcdfb5">Covariance</a> (const Eigen::RowVectorXd &amp;x, const Eigen::RowVectorXd &amp;y)</td></tr>
<tr class="memdesc:a2bef1676f0081a698038a646f8bcdfb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the Covariance between two double dataset <img class="formulaInl" alt="$\vec{X}, \vec{Y}$" src="form_21.png"/>.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \operatorname{Cov}\left(x,y\right) = \frac{\sum_{i=1}^{N}{x_{i}y_{i}} - \left(\sum_{i=1}^{N}{x_{i}}\sum_{i=1}^{N}{y_{i}}\right)/N}{N}\]" src="form_22.png"/>
</p>
  <a href="#a2bef1676f0081a698038a646f8bcdfb5">More...</a><br /></td></tr>
<tr class="separator:a2bef1676f0081a698038a646f8bcdfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c58e4b585bd4636bc884fe179edc415"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a3c58e4b585bd4636bc884fe179edc415">ShrunkCovariance</a> (Eigen::MatrixXd &amp;cov, double shrinkage=0.1)</td></tr>
<tr class="memdesc:a3c58e4b585bd4636bc884fe179edc415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrunks the Covariance Matrix <img class="formulaInl" alt="$ M $" src="form_24.png"/> (destructive operation).<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ (1 - \text{shrinkage}) \times M_{\operatorname{Cov}} + \frac{\text{shrinkage} \times \operatorname{trace}(M_{Cov})}{N} \times I_N \]" src="form_25.png"/>
</p>
  <a href="#a3c58e4b585bd4636bc884fe179edc415">More...</a><br /></td></tr>
<tr class="separator:a3c58e4b585bd4636bc884fe179edc415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f7e1777e1af401c001fcf4295bfd4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a52f7e1777e1af401c001fcf4295bfd4a">ShrunkCovariance</a> (const Eigen::MatrixXd &amp;in, Eigen::MatrixXd &amp;out, double shrinkage=0.1)</td></tr>
<tr class="memdesc:a52f7e1777e1af401c001fcf4295bfd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrunks the Covariance Matrix <img class="formulaInl" alt="$ M $" src="form_24.png"/> (non destructive operation).<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ (1 - \text{shrinkage}) \times M_{\operatorname{Cov}} + \frac{\text{shrinkage} \times \operatorname{trace}(M_{Cov})}{N} \times I_N \]" src="form_25.png"/>
</p>
  <a href="#a52f7e1777e1af401c001fcf4295bfd4a">More...</a><br /></td></tr>
<tr class="separator:a52f7e1777e1af401c001fcf4295bfd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3830d8f2116e6ab151ae9b7e142f855"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#aa3830d8f2116e6ab151ae9b7e142f855">CovarianceMatrix</a> (const Eigen::MatrixXd &amp;in, Eigen::MatrixXd &amp;out, <a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9">EEstimator</a> estimator=<a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9a18448d7ac6e52fa9f9bb5861b0397b6e">EEstimator::COV</a>, <a class="el" href="namespace_geometry.html#a523d040f5c68154ee9e6647768d26841">EStandardization</a> standard=<a class="el" href="namespace_geometry.html#a523d040f5c68154ee9e6647768d26841a4f1f6016fc9f3f2353c0cc7c67b292bd">EStandardization::Center</a>)</td></tr>
<tr class="memdesc:aa3830d8f2116e6ab151ae9b7e142f855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select the function to call for the covariance matrix.<br />
 <a href="#aa3830d8f2116e6ab151ae9b7e142f855">More...</a><br /></td></tr>
<tr class="separator:aa3830d8f2116e6ab151ae9b7e142f855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b74ff6628bef643a5d49615f3ec374"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a28b74ff6628bef643a5d49615f3ec374">CovarianceMatrixCOV</a> (const Eigen::MatrixXd &amp;samples, Eigen::MatrixXd &amp;cov)</td></tr>
<tr class="memdesc:a28b74ff6628bef643a5d49615f3ec374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the covariance matrix.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ M_{\operatorname{Cov}} = \begin{pmatrix} V\left(x_1\right) &amp; \operatorname{Cov}\left(x_1,x_2\right) &amp;\cdots &amp; \operatorname{Cov}\left(x_1,x_N\right)\\ \operatorname{Cov}\left(x_2,x_1\right) &amp;\ddots &amp; \ddots &amp; \vdots \\ \vdots &amp; \ddots &amp; \ddots &amp; \vdots \\ \operatorname{Cov}\left(x_N,x_1\right) &amp;\cdots &amp; \cdots &amp; V\left(x_N\right) \end{pmatrix} \quad\quad \text{with } x_i \text{ the feature } i \]" src="form_27.png"/>
</p>
<p><br />
With the <a class="el" href="namespace_geometry.html#a91b0a15045364dad7728f02677c1051c" title="Calculation of the Variance of a double dataset .   ">Variance</a> and <a class="el" href="namespace_geometry.html#a2bef1676f0081a698038a646f8bcdfb5" title="Calculation of the Covariance between two double dataset .   ">Covariance</a> function.  <a href="#a28b74ff6628bef643a5d49615f3ec374">More...</a><br /></td></tr>
<tr class="separator:a28b74ff6628bef643a5d49615f3ec374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99669e1e1c24331620421be90927f834"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a99669e1e1c24331620421be90927f834">CovarianceMatrixSCM</a> (const Eigen::MatrixXd &amp;samples, Eigen::MatrixXd &amp;cov)</td></tr>
<tr class="memdesc:a99669e1e1c24331620421be90927f834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the covariance matrix by the method : Normalized Spatial Covariance Matrix (SCM).<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ M_{\operatorname{Cov_{SCM}}} = \frac{XX^{\mathsf{T}}}{\operatorname{trace}{\left(XX^{\mathsf{T}}\right)}} \]" src="form_28.png"/>
</p>
  <a href="#a99669e1e1c24331620421be90927f834">More...</a><br /></td></tr>
<tr class="separator:a99669e1e1c24331620421be90927f834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785aaaaed209dd8b3f674d4474897feb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a785aaaaed209dd8b3f674d4474897feb">CovarianceMatrixLWF</a> (const Eigen::MatrixXd &amp;samples, Eigen::MatrixXd &amp;cov)</td></tr>
<tr class="memdesc:a785aaaaed209dd8b3f674d4474897feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the covariance matrix and shrinkage by the method : Ledoit and Wolf.<br />
</p><ol type="1">
<li>Compute the Covariance Matrix (see <a class="el" href="namespace_geometry.html#a28b74ff6628bef643a5d49615f3ec374" title="Calculation of the covariance matrix.   With the Variance and Covariance function. ">CovarianceMatrixCOV</a>) <img class="formulaInl" alt="$ M_{\operatorname{Cov}} $" src="form_29.png"/></li>
<li>Compute the Ledoit and Wolf Shrinkage</li>
<li>Shrunk the Matrix (see <a class="el" href="namespace_geometry.html#a3c58e4b585bd4636bc884fe179edc415" title="Shrunks the Covariance Matrix  (destructive operation).   ">ShrunkCovariance</a>) </li>
</ol>
 <a href="#a785aaaaed209dd8b3f674d4474897feb">More...</a><br /></td></tr>
<tr class="separator:a785aaaaed209dd8b3f674d4474897feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddcc48b45d074b7c38e76632517353e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a0ddcc48b45d074b7c38e76632517353e">CovarianceMatrixOAS</a> (const Eigen::MatrixXd &amp;samples, Eigen::MatrixXd &amp;cov)</td></tr>
<tr class="memdesc:a0ddcc48b45d074b7c38e76632517353e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the covariance matrix and shrinkage by the method : Oracle Approximating Shrinkage (OAS).<br />
</p><ol type="1">
<li>Compute the Covariance Matrix (see <a class="el" href="namespace_geometry.html#a28b74ff6628bef643a5d49615f3ec374" title="Calculation of the covariance matrix.   With the Variance and Covariance function. ">CovarianceMatrixCOV</a>) <img class="formulaInl" alt="$ M_{\operatorname{Cov}} $" src="form_29.png"/></li>
<li>Compute the Oracle Approximating Shrinkage</li>
<li>Shrunk the Matrix (see <a class="el" href="namespace_geometry.html#a3c58e4b585bd4636bc884fe179edc415" title="Shrunks the Covariance Matrix  (destructive operation).   ">ShrunkCovariance</a>) </li>
</ol>
 <a href="#a0ddcc48b45d074b7c38e76632517353e">More...</a><br /></td></tr>
<tr class="separator:a0ddcc48b45d074b7c38e76632517353e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53c7c9a08cd380bbcb3cd73158ff446"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#ac53c7c9a08cd380bbcb3cd73158ff446">CovarianceMatrixMCD</a> (const Eigen::MatrixXd &amp;samples, Eigen::MatrixXd &amp;cov)</td></tr>
<tr class="memdesc:ac53c7c9a08cd380bbcb3cd73158ff446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the covariance matrix and shrinkage by the method : Minimum Covariance Determinant (MCD).  <a href="#ac53c7c9a08cd380bbcb3cd73158ff446">More...</a><br /></td></tr>
<tr class="separator:ac53c7c9a08cd380bbcb3cd73158ff446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8410e9e47cdfecb0e34522dae71271ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a8410e9e47cdfecb0e34522dae71271ff">CovarianceMatrixCOR</a> (const Eigen::MatrixXd &amp;samples, Eigen::MatrixXd &amp;cov)</td></tr>
<tr class="memdesc:a8410e9e47cdfecb0e34522dae71271ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the covariance matrix by the method : Pearson Correlation.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ M_{\operatorname{Cov_{COR}}}\left(i,j\right) = \frac{ M_{\operatorname{Cov}}\left(i,j\right) } { \sqrt{ M_{\operatorname{Cov}}\left(i,i\right) * M_{\operatorname{Cov}}\left(j,j\right) } } \]" src="form_34.png"/>
</p>
  <a href="#a8410e9e47cdfecb0e34522dae71271ff">More...</a><br /></td></tr>
<tr class="separator:a8410e9e47cdfecb0e34522dae71271ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eeeb52e92fbdc25eb16d31bf0450a2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a5eeeb52e92fbdc25eb16d31bf0450a2f">CovarianceMatrixIDE</a> (const Eigen::MatrixXd &amp;samples, Eigen::MatrixXd &amp;cov)</td></tr>
<tr class="memdesc:a5eeeb52e92fbdc25eb16d31bf0450a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Identity matrix <img class="formulaInl" alt="$ I_N $" src="form_35.png"/>.  <a href="#a5eeeb52e92fbdc25eb16d31bf0450a2f">More...</a><br /></td></tr>
<tr class="separator:a5eeeb52e92fbdc25eb16d31bf0450a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa086d103988d1765494604ea8f00ecc4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#aa086d103988d1765494604ea8f00ecc4">Distance</a> (const Eigen::MatrixXd &amp;a, const Eigen::MatrixXd &amp;b, <a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5">EMetric</a> metric=<a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5a61ea1974dd974297913b1fa2f0470d26">EMetric::Riemann</a>)</td></tr>
<tr class="memdesc:aa086d103988d1765494604ea8f00ecc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the distance between two matrix with the selected <code>metric</code>.  <a href="#aa086d103988d1765494604ea8f00ecc4">More...</a><br /></td></tr>
<tr class="separator:aa086d103988d1765494604ea8f00ecc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f3b2ed8219ca2f1cce0791a0ff4179"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a21f3b2ed8219ca2f1cce0791a0ff4179">DistanceRiemann</a> (const Eigen::MatrixXd &amp;a, const Eigen::MatrixXd &amp;b)</td></tr>
<tr class="memdesc:a21f3b2ed8219ca2f1cce0791a0ff4179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Riemannian Distance between two covariance matrices A and B.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ d_{\text{R}}(A,B) = \sqrt{\left( \sum_i \log\left(\lambda_i\right)^2 \right)} \]" src="form_36.png"/>
</p>
<p> with : <img class="formulaInl" alt="$\lambda_i$" src="form_37.png"/> the joint eigenvalues of <img class="formulaInl" alt="$A$" src="form_38.png"/> and <img class="formulaInl" alt="$B$" src="form_39.png"/>.  <a href="#a21f3b2ed8219ca2f1cce0791a0ff4179">More...</a><br /></td></tr>
<tr class="separator:a21f3b2ed8219ca2f1cce0791a0ff4179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9360b11584fe2e5126e7fb2f440ef9f2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a9360b11584fe2e5126e7fb2f440ef9f2">DistanceEuclidian</a> (const Eigen::MatrixXd &amp;a, const Eigen::MatrixXd &amp;b)</td></tr>
<tr class="memdesc:a9360b11584fe2e5126e7fb2f440ef9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidian Distance between two covariance matrices A and B.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ d_{\text{E}}(A,B) = \left\lVert B - A \right\rVert\]" src="form_40.png"/>
</p>
  <a href="#a9360b11584fe2e5126e7fb2f440ef9f2">More...</a><br /></td></tr>
<tr class="separator:a9360b11584fe2e5126e7fb2f440ef9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e2aebdd4acb2c42ee28f20b692b00b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#af4e2aebdd4acb2c42ee28f20b692b00b">DistanceLogEuclidian</a> (const Eigen::MatrixXd &amp;a, const Eigen::MatrixXd &amp;b)</td></tr>
<tr class="memdesc:af4e2aebdd4acb2c42ee28f20b692b00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Log Euclidian Distance between two covariance matrices A and B.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ d_{\text{lE}}(A,B) = \left\lVert \log\left(B\right) - \log\left(A\right) \right\rVert\]" src="form_41.png"/>
</p>
  <a href="#af4e2aebdd4acb2c42ee28f20b692b00b">More...</a><br /></td></tr>
<tr class="separator:af4e2aebdd4acb2c42ee28f20b692b00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad704a591f9f0144d0397420a8efb619c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#ad704a591f9f0144d0397420a8efb619c">DistanceLogDet</a> (const Eigen::MatrixXd &amp;a, const Eigen::MatrixXd &amp;b)</td></tr>
<tr class="memdesc:ad704a591f9f0144d0397420a8efb619c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Log-det Distance between two covariance matrices A and B.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ d_{\text{lD}}(A,B) = \sqrt{\log\left(\left\lvert\frac{A + B}{2}\right\rvert\right) - 0.5 \times \log\left( \left\lvert A \right\rvert \times \left\lvert B \right\rvert \right)} \]" src="form_42.png"/>
</p>
<p> with : <img class="formulaInl" alt="$\left\lvert A \right\rvert$" src="form_43.png"/> the determinant of <img class="formulaInl" alt="$A$" src="form_38.png"/>.  <a href="#ad704a591f9f0144d0397420a8efb619c">More...</a><br /></td></tr>
<tr class="separator:ad704a591f9f0144d0397420a8efb619c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac13e624230cda19d4d59b711b8a763"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#acac13e624230cda19d4d59b711b8a763">DistanceKullback</a> (const Eigen::MatrixXd &amp;a, const Eigen::MatrixXd &amp;b)</td></tr>
<tr class="memdesc:acac13e624230cda19d4d59b711b8a763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Kullback Leibler Divergence between two covariance matrices A and B.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ d_{\text{K}}(A,B) = 0.5 \times \left( \operatorname{trace}\left(B^{-1} ~ A\right) - N + \log\left( \frac{\left\lvert B \right\rvert }{\left\lvert A \right\rvert} \right) \right) \]" src="form_44.png"/>
</p>
<p> with : <img class="formulaInl" alt="$\left\lvert A \right\rvert$" src="form_43.png"/> the determinant of <img class="formulaInl" alt="$A$" src="form_38.png"/>.  <a href="#acac13e624230cda19d4d59b711b8a763">More...</a><br /></td></tr>
<tr class="separator:acac13e624230cda19d4d59b711b8a763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c059c124f49eced60836607b6952d1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a48c059c124f49eced60836607b6952d1">DistanceKullbackSym</a> (const Eigen::MatrixXd &amp;a, const Eigen::MatrixXd &amp;b)</td></tr>
<tr class="memdesc:a48c059c124f49eced60836607b6952d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Symetric Kullback Leibler Divergence between two covariance matrices A and B.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ d_{\text{sK}}(A,B) = d_\text{K}(A, B) + d_\text{K}(B, A) \]" src="form_45.png"/>
</p>
  <a href="#a48c059c124f49eced60836607b6952d1">More...</a><br /></td></tr>
<tr class="separator:a48c059c124f49eced60836607b6952d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29b8ac52fdde0633b37bc36378caa86"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#ad29b8ac52fdde0633b37bc36378caa86">DistanceWasserstein</a> (const Eigen::MatrixXd &amp;a, const Eigen::MatrixXd &amp;b)</td></tr>
<tr class="memdesc:ad29b8ac52fdde0633b37bc36378caa86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Wasserstein Distance between two covariance matrices A and B.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ d_{\text{W}}(A,B) = \sqrt{ \operatorname{trace}\left(A + B - 2 \times \left(A^{1/2} ~ B ~ A^{1/2}\right)^{1/2}\right) } \]" src="form_46.png"/>
</p>
  <a href="#ad29b8ac52fdde0633b37bc36378caa86">More...</a><br /></td></tr>
<tr class="separator:ad29b8ac52fdde0633b37bc36378caa86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd3153028daa58925ba9ebe442b9ef4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a8cd3153028daa58925ba9ebe442b9ef4">Featurization</a> (const Eigen::MatrixXd &amp;in, Eigen::RowVectorXd &amp;out, bool tangent=true, const Eigen::MatrixXd &amp;ref=Eigen::MatrixXd())</td></tr>
<tr class="memdesc:a8cd3153028daa58925ba9ebe442b9ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the features vector of covariance matrix with the selected method.  <a href="#a8cd3153028daa58925ba9ebe442b9ef4">More...</a><br /></td></tr>
<tr class="separator:a8cd3153028daa58925ba9ebe442b9ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523323724beb9c8e14ae54cbb01c5ec1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a523323724beb9c8e14ae54cbb01c5ec1">UnFeaturization</a> (const Eigen::RowVectorXd &amp;in, Eigen::MatrixXd &amp;out, bool tangent=true, const Eigen::MatrixXd &amp;ref=Eigen::MatrixXd())</td></tr>
<tr class="memdesc:a523323724beb9c8e14ae54cbb01c5ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the covariance matrix of features vector with the selected method.  <a href="#a523323724beb9c8e14ae54cbb01c5ec1">More...</a><br /></td></tr>
<tr class="separator:a523323724beb9c8e14ae54cbb01c5ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65d5cf9573f3592a79104926a9db4f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#ae65d5cf9573f3592a79104926a9db4f9">SqueezeUpperTriangle</a> (const Eigen::MatrixXd &amp;in, Eigen::RowVectorXd &amp;out, bool rowMajor=true)</td></tr>
<tr class="memdesc:ae65d5cf9573f3592a79104926a9db4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squeeze the upper triangle of <img class="formulaInl" alt="$N \times N$" src="form_47.png"/> square matrix to a <img class="formulaInl" alt="$\frac{N\left(N+1\right)}{2}$" src="form_48.png"/> Vector.  <a href="#ae65d5cf9573f3592a79104926a9db4f9">More...</a><br /></td></tr>
<tr class="separator:ae65d5cf9573f3592a79104926a9db4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac6eaab76672ed2c5df782812bf3d5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a5ac6eaab76672ed2c5df782812bf3d5d">UnSqueezeUpperTriangle</a> (const Eigen::RowVectorXd &amp;in, Eigen::MatrixXd &amp;out, bool rowMajor=true)</td></tr>
<tr class="memdesc:a5ac6eaab76672ed2c5df782812bf3d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the upper triangle of <img class="formulaInl" alt="$\frac{N\left(N+1\right)}{2}$" src="form_48.png"/> Vector to a <img class="formulaInl" alt="$N \times N$" src="form_47.png"/> square matrix.  <a href="#a5ac6eaab76672ed2c5df782812bf3d5d">More...</a><br /></td></tr>
<tr class="separator:a5ac6eaab76672ed2c5df782812bf3d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbe7965035abc75c92513d07231c1e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#adcbe7965035abc75c92513d07231c1e1">TangentSpace</a> (const Eigen::MatrixXd &amp;in, Eigen::RowVectorXd &amp;out, const Eigen::MatrixXd &amp;ref=Eigen::MatrixXd())</td></tr>
<tr class="memdesc:adcbe7965035abc75c92513d07231c1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project a covariance matrices ( <img class="formulaInl" alt="$M$" src="form_54.png"/>) in the tangent space ( <img class="formulaInl" alt="$\mathcal{T}$" src="form_55.png"/>) according to the given reference point ( <img class="formulaInl" alt="$M_\text{Ref}$" src="form_56.png"/>). <br />
  <a href="#adcbe7965035abc75c92513d07231c1e1">More...</a><br /></td></tr>
<tr class="separator:adcbe7965035abc75c92513d07231c1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f5572bcfe17760736d45a0d4d04430"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a30f5572bcfe17760736d45a0d4d04430">UnTangentSpace</a> (const Eigen::RowVectorXd &amp;in, Eigen::MatrixXd &amp;out, const Eigen::MatrixXd &amp;ref=Eigen::MatrixXd())</td></tr>
<tr class="memdesc:a30f5572bcfe17760736d45a0d4d04430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project a Tangent space vectors in the manifold according to the given reference point. <br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{aligned} \text{With : } M_\text{Ts} &amp;= \operatorname{UnSqueezeUpperTriangle}(V_\text{Ts}) \quad \text{ and } \quad \mathsf{U}_{M}\text{ the upper triangular out.}\\ M_\text{Coeffs} &amp;= \operatorname{diag}\left(M_\text{Ts}\right) + \frac{\mathsf{U}_{M_\text{Ts}} + \mathsf{U}_{M_\text{Ts}}^{\mathsf{T}}}{\sqrt{2}}\\ \Rightarrow M &amp;= M_\text{Ref}^{1/2} ~ \exp{\left(M_\text{Coeffs}\right)} ~ M_\text{Ref}^{1/2} \end{aligned} \]" src="form_61.png"/>
</p>
  <a href="#a30f5572bcfe17760736d45a0d4d04430">More...</a><br /></td></tr>
<tr class="separator:a30f5572bcfe17760736d45a0d4d04430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7bdc496eb1d5ad2132f01fea8e34b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a3a7bdc496eb1d5ad2132f01fea8e34b7">Geodesic</a> (const Eigen::MatrixXd &amp;a, const Eigen::MatrixXd &amp;b, Eigen::MatrixXd &amp;g, <a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5">EMetric</a> metric=<a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5a61ea1974dd974297913b1fa2f0470d26">EMetric::Riemann</a>, double alpha=0.5)</td></tr>
<tr class="memdesc:a3a7bdc496eb1d5ad2132f01fea8e34b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the matrix at the position alpha on the geodesic between A and B with the selected <code>metric</code>.<br />
 <a href="#a3a7bdc496eb1d5ad2132f01fea8e34b7">More...</a><br /></td></tr>
<tr class="separator:a3a7bdc496eb1d5ad2132f01fea8e34b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dbac25b3eb3e105086fbf365b3fc4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a94dbac25b3eb3e105086fbf365b3fc4e">GeodesicRiemann</a> (const Eigen::MatrixXd &amp;a, const Eigen::MatrixXd &amp;b, Eigen::MatrixXd &amp;g, double alpha=0.5)</td></tr>
<tr class="memdesc:a94dbac25b3eb3e105086fbf365b3fc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the matrix at the position alpha on the Riemannian geodesic between A and B. <br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \gamma_\text{R} = A^{1/2} ~ \left( A^{-1/2} ~ B ~ A^{-1/2} \right)^\alpha ~ A^{1/2} \]" src="form_63.png"/>
</p>
  <a href="#a94dbac25b3eb3e105086fbf365b3fc4e">More...</a><br /></td></tr>
<tr class="separator:a94dbac25b3eb3e105086fbf365b3fc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2adb606bd7e956a6d4377ae0210ff08e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a2adb606bd7e956a6d4377ae0210ff08e">GeodesicEuclidian</a> (const Eigen::MatrixXd &amp;a, const Eigen::MatrixXd &amp;b, Eigen::MatrixXd &amp;g, double alpha=0.5)</td></tr>
<tr class="memdesc:a2adb606bd7e956a6d4377ae0210ff08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the matrix at the position alpha on the Euclidean geodesic between A and B.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \gamma_\text{E} = \left(1 - \alpha \right) \times A + \alpha \times B \]" src="form_64.png"/>
</p>
  <a href="#a2adb606bd7e956a6d4377ae0210ff08e">More...</a><br /></td></tr>
<tr class="separator:a2adb606bd7e956a6d4377ae0210ff08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da82ed68dccc3a8fa0c0d279ffc60f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a3da82ed68dccc3a8fa0c0d279ffc60f8">GeodesicLogEuclidian</a> (const Eigen::MatrixXd &amp;a, const Eigen::MatrixXd &amp;b, Eigen::MatrixXd &amp;g, double alpha=0.5)</td></tr>
<tr class="memdesc:a3da82ed68dccc3a8fa0c0d279ffc60f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the matrix at the position alpha on the Log Euclidean geodesic between A and B. <br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \gamma_\text{LogE} = \exp\left(\left(1 - \alpha \right) \times \log\left(A\right) + \alpha \times \log\left(B\right) \right)\]" src="form_65.png"/>
</p>
  <a href="#a3da82ed68dccc3a8fa0c0d279ffc60f8">More...</a><br /></td></tr>
<tr class="separator:a3da82ed68dccc3a8fa0c0d279ffc60f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed64c08ac404aa639686e06d9ae30f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a2ed64c08ac404aa639686e06d9ae30f1">GeodesicIdentity</a> (const Eigen::MatrixXd &amp;a, const Eigen::MatrixXd &amp;b, Eigen::MatrixXd &amp;g, double alpha=0.5)</td></tr>
<tr class="memdesc:a2ed64c08ac404aa639686e06d9ae30f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the matrix at the position alpha on the Identity geodesic. <br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \gamma_\text{I} = I_N \]" src="form_66.png"/>
</p>
  <a href="#a2ed64c08ac404aa639686e06d9ae30f1">More...</a><br /></td></tr>
<tr class="separator:a2ed64c08ac404aa639686e06d9ae30f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f34ce11b4949cd50f85eb750f6d525"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a18f34ce11b4949cd50f85eb750f6d525">Mean</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;covs, Eigen::MatrixXd &amp;mean, <a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5">EMetric</a> metric=<a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5a61ea1974dd974297913b1fa2f0470d26">EMetric::Riemann</a>)</td></tr>
<tr class="memdesc:a18f34ce11b4949cd50f85eb750f6d525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean of vector of covariance matrix with the selected <code>metric</code>.  <a href="#a18f34ce11b4949cd50f85eb750f6d525">More...</a><br /></td></tr>
<tr class="separator:a18f34ce11b4949cd50f85eb750f6d525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed84358aabc6a65364775ad43294acc5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#aed84358aabc6a65364775ad43294acc5">AJDPham</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;covs, Eigen::MatrixXd &amp;ajd, double epsilon=0.0001, int maxIter=15)</td></tr>
<tr class="memdesc:aed84358aabc6a65364775ad43294acc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate Joint Diagonalization based on pham's algorithm.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_\text{AJD} = \cdots \]" src="form_68.png"/>
</p>
  <a href="#aed84358aabc6a65364775ad43294acc5">More...</a><br /></td></tr>
<tr class="separator:aed84358aabc6a65364775ad43294acc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1d6e65d7dcb047be1b64d9263b8d7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#aed1d6e65d7dcb047be1b64d9263b8d7f">MeanRiemann</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;covs, Eigen::MatrixXd &amp;mean)</td></tr>
<tr class="memdesc:aed1d6e65d7dcb047be1b64d9263b8d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Mean with the Riemannian Mean.<br />
</p><ol type="1">
<li>Compute the Classical Mean <img class="formulaInl" alt="$ C_{\mu_\text{E}} $" src="form_69.png"/> (see <a class="el" href="namespace_geometry.html#a2abb6c24f0a2eb4ccd89a7ecef5d7a28" title="Compute the Euclidian Mean.   ">MeanEuclidian</a>)</li>
<li>Update with an iterative procedure that stops after 50 iterations or when one of two criterions is under <img class="formulaInl" alt="$ 10^{-4}$" src="form_70.png"/> </li>
</ol>
 <a href="#aed1d6e65d7dcb047be1b64d9263b8d7f">More...</a><br /></td></tr>
<tr class="separator:aed1d6e65d7dcb047be1b64d9263b8d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abb6c24f0a2eb4ccd89a7ecef5d7a28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a2abb6c24f0a2eb4ccd89a7ecef5d7a28">MeanEuclidian</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;covs, Eigen::MatrixXd &amp;mean)</td></tr>
<tr class="memdesc:a2abb6c24f0a2eb4ccd89a7ecef5d7a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euclidian Mean.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_{\mu_\text{E}} =\frac{1}{N} \sum_i{C_i}\]" src="form_78.png"/>
</p>
  <a href="#a2abb6c24f0a2eb4ccd89a7ecef5d7a28">More...</a><br /></td></tr>
<tr class="separator:a2abb6c24f0a2eb4ccd89a7ecef5d7a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95d3f4cb13e4b4c26311e5ba143924c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#ab95d3f4cb13e4b4c26311e5ba143924c">MeanLogEuclidian</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;covs, Eigen::MatrixXd &amp;mean)</td></tr>
<tr class="memdesc:ab95d3f4cb13e4b4c26311e5ba143924c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Log Euclidiean Mean.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_{\mu_\text{lE}} =\exp\left(\frac{1}{N} \sum_i{\log\left(C_i\right)}\right)\]" src="form_79.png"/>
</p>
  <a href="#ab95d3f4cb13e4b4c26311e5ba143924c">More...</a><br /></td></tr>
<tr class="separator:ab95d3f4cb13e4b4c26311e5ba143924c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3f50490006a6ee3fe513f067f56e5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a7b3f50490006a6ee3fe513f067f56e5e">MeanLogDet</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;covs, Eigen::MatrixXd &amp;mean)</td></tr>
<tr class="memdesc:a7b3f50490006a6ee3fe513f067f56e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Log Determinant Mean.<br />
</p><ol type="1">
<li>Compute the Classical Mean <img class="formulaInl" alt="$ C_{\mu_\text{E}} $" src="form_69.png"/> (see <a class="el" href="namespace_geometry.html#a2abb6c24f0a2eb4ccd89a7ecef5d7a28" title="Compute the Euclidian Mean.   ">MeanEuclidian</a>)</li>
<li>Update with an iterative procedure that stops after 50 iterations or when criterion is under <img class="formulaInl" alt="$ 10^{-4}$" src="form_70.png"/> </li>
</ol>
 <a href="#a7b3f50490006a6ee3fe513f067f56e5e">More...</a><br /></td></tr>
<tr class="separator:a7b3f50490006a6ee3fe513f067f56e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1cc6a45cc9f90f04d5f4665d884a2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#aae1cc6a45cc9f90f04d5f4665d884a2e">MeanKullback</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;covs, Eigen::MatrixXd &amp;mean)</td></tr>
<tr class="memdesc:aae1cc6a45cc9f90f04d5f4665d884a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Kullback Mean.<br />
The mean is the Geodesic center between the Euclidian and the Harmonic Mean.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_{\mu_\text{K}} = \gamma \left( C_{\mu_{\text{E}}}, C_{\mu_{\text{H}}} \right) \]" src="form_83.png"/>
</p>
  <a href="#aae1cc6a45cc9f90f04d5f4665d884a2e">More...</a><br /></td></tr>
<tr class="separator:aae1cc6a45cc9f90f04d5f4665d884a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406589cb31e0f582b9c9221e6f2438ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a406589cb31e0f582b9c9221e6f2438ac">MeanWasserstein</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;covs, Eigen::MatrixXd &amp;mean)</td></tr>
<tr class="memdesc:a406589cb31e0f582b9c9221e6f2438ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Wasserstein Mean.<br />
</p><ol type="1">
<li>Compute the Classical Mean <img class="formulaInl" alt="$ C_{\mu_\text{E}} $" src="form_69.png"/> (see <a class="el" href="namespace_geometry.html#a2abb6c24f0a2eb4ccd89a7ecef5d7a28" title="Compute the Euclidian Mean.   ">MeanEuclidian</a>)</li>
<li>Update with an iterative procedure that stops after 50 iterations or when criterion is under <img class="formulaInl" alt="$ 10^{-4}$" src="form_70.png"/> </li>
</ol>
 <a href="#a406589cb31e0f582b9c9221e6f2438ac">More...</a><br /></td></tr>
<tr class="separator:a406589cb31e0f582b9c9221e6f2438ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ad24df7d60542554c7902e0b2ef85c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a93ad24df7d60542554c7902e0b2ef85c">MeanALE</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;covs, Eigen::MatrixXd &amp;mean)</td></tr>
<tr class="memdesc:a93ad24df7d60542554c7902e0b2ef85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Approximate joint diagonalization based log-Euclidean (ALE) Mean. <br />
</p><ol type="1">
<li>Compute the Approximate Joint Diagonalization <img class="formulaInl" alt="$ C_\text{AJD} $" src="form_88.png"/> (see <a class="el" href="namespace_geometry.html#aed84358aabc6a65364775ad43294acc5" title="Approximate Joint Diagonalization based on pham&#39;s algorithm.   ">AJDPham</a>)</li>
<li>Update with an iterative procedure that stops after 50 iterations or when criterion is under <img class="formulaInl" alt="$ 10^{-4}$" src="form_70.png"/> </li>
</ol>
 <a href="#a93ad24df7d60542554c7902e0b2ef85c">More...</a><br /></td></tr>
<tr class="separator:a93ad24df7d60542554c7902e0b2ef85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862eacff8d80037b931e71c5d096754a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a862eacff8d80037b931e71c5d096754a">MeanHarmonic</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;covs, Eigen::MatrixXd &amp;mean)</td></tr>
<tr class="memdesc:a862eacff8d80037b931e71c5d096754a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Harmonic Mean.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_{\mu_\text{H}} = (\frac{1}{N} \sum_i{C_i}^{-1})^{-1} \]" src="form_94.png"/>
</p>
  <a href="#a862eacff8d80037b931e71c5d096754a">More...</a><br /></td></tr>
<tr class="separator:a862eacff8d80037b931e71c5d096754a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54656e27a1e7aedb6597a3f836fc1caa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a54656e27a1e7aedb6597a3f836fc1caa">MeanIdentity</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;covs, Eigen::MatrixXd &amp;mean)</td></tr>
<tr class="memdesc:a54656e27a1e7aedb6597a3f836fc1caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the Identity Matrix.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_{\mu_\text{I}} = I_N \]" src="form_95.png"/>
</p>
  <a href="#a54656e27a1e7aedb6597a3f836fc1caa">More...</a><br /></td></tr>
<tr class="separator:a54656e27a1e7aedb6597a3f836fc1caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3398441a105c55745771f8cc0ba4df00"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </td></tr>
<tr class="memitem:a3398441a105c55745771f8cc0ba4df00"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a3398441a105c55745771f8cc0ba4df00">Median</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a3398441a105c55745771f8cc0ba4df00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the median of stl vector.  <a href="#a3398441a105c55745771f8cc0ba4df00">More...</a><br /></td></tr>
<tr class="separator:a3398441a105c55745771f8cc0ba4df00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58f4c5c183e4368cf33ca1d669e4322"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#ad58f4c5c183e4368cf33ca1d669e4322">Median</a> (const Eigen::MatrixXd &amp;m)</td></tr>
<tr class="memdesc:ad58f4c5c183e4368cf33ca1d669e4322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the median of values of the Eigen Matrix.  <a href="#ad58f4c5c183e4368cf33ca1d669e4322">More...</a><br /></td></tr>
<tr class="separator:ad58f4c5c183e4368cf33ca1d669e4322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4322a29f9781f937dc5fe0e0bbe9cdcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a4322a29f9781f937dc5fe0e0bbe9cdcc">MedianEuclidian</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;matrices, Eigen::MatrixXd &amp;median, const double epsilon=0.0001, const size_t maxIter=50)</td></tr>
<tr class="memdesc:a4322a29f9781f937dc5fe0e0bbe9cdcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the median of vector of matrix with the Weiszfeld's algorithm. <br />
 To compute this median, we start by computing the initial median of the dataset by taking each element of the matrices independently. That is to say that for the element at position i, j(a_i, j) of the matrices, we computes the median of the elements a_i, j of all the matrices of the dataset. We thus have an initial median for our dataset. <br />
 Then, we refine our median by the iterative algorithm of Weiszfeld:  <a href="#a4322a29f9781f937dc5fe0e0bbe9cdcc">More...</a><br /></td></tr>
<tr class="separator:a4322a29f9781f937dc5fe0e0bbe9cdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7027dd258b94e5abc3f99361598ac9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a7f7027dd258b94e5abc3f99361598ac9">MedianRiemann</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;matrices, Eigen::MatrixXd &amp;median, const double epsilon=0.0001, const size_t maxIter=50)</td></tr>
<tr class="memdesc:a7f7027dd258b94e5abc3f99361598ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the median of vector of matrix with the Riemman Barycentre. <br />
  <a href="#a7f7027dd258b94e5abc3f99361598ac9">More...</a><br /></td></tr>
<tr class="separator:a7f7027dd258b94e5abc3f99361598ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae832de6c0cee498670b1093f4528b031"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#ae832de6c0cee498670b1093f4528b031">MedianIdentity</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;matrices, Eigen::MatrixXd &amp;median)</td></tr>
<tr class="memdesc:ae832de6c0cee498670b1093f4528b031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the identity matrix has median.  <a href="#ae832de6c0cee498670b1093f4528b031">More...</a><br /></td></tr>
<tr class="separator:ae832de6c0cee498670b1093f4528b031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b864473632f514fb5c9edb56312e9f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a6b864473632f514fb5c9edb56312e9f9">Median</a> (const std::vector&lt; Eigen::MatrixXd &gt; &amp;matrices, Eigen::MatrixXd &amp;median, const double epsilon=0.0001, const size_t maxIter=50, const <a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5">EMetric</a> &amp;metric=<a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5aedca8775d78e240ca6902e89c60621bb">EMetric::Euclidian</a>)</td></tr>
<tr class="memdesc:a6b864473632f514fb5c9edb56312e9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the median of vector of matrix with the Weiszfeld's algorithm for Euclidian Metric and Riemman Barycentre.  <a href="#a6b864473632f514fb5c9edb56312e9f9">More...</a><br /></td></tr>
<tr class="separator:a6b864473632f514fb5c9edb56312e9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b695df8e8d0ebf33ef1c6a85614ed6e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a5b695df8e8d0ebf33ef1c6a85614ed6e">toString</a> (const <a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5">EMetric</a> metric)</td></tr>
<tr class="memdesc:a5b695df8e8d0ebf33ef1c6a85614ed6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert metric to string.  <a href="#a5b695df8e8d0ebf33ef1c6a85614ed6e">More...</a><br /></td></tr>
<tr class="separator:a5b695df8e8d0ebf33ef1c6a85614ed6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ccff0c2616d30637002c57b8d98c6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5">EMetric</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a52ccff0c2616d30637002c57b8d98c6b">StringToMetric</a> (const std::string &amp;metric)</td></tr>
<tr class="memdesc:a52ccff0c2616d30637002c57b8d98c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to metric.  <a href="#a52ccff0c2616d30637002c57b8d98c6b">More...</a><br /></td></tr>
<tr class="separator:a52ccff0c2616d30637002c57b8d98c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ad7cbb8a04aeb2cf16fd13f85ee07d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#a50ad7cbb8a04aeb2cf16fd13f85ee07d">doubleRange</a> (const double begin, const double end, const double step=1.0, const bool closed=true)</td></tr>
<tr class="memdesc:a50ad7cbb8a04aeb2cf16fd13f85ee07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a range of double value.  <a href="#a50ad7cbb8a04aeb2cf16fd13f85ee07d">More...</a><br /></td></tr>
<tr class="separator:a50ad7cbb8a04aeb2cf16fd13f85ee07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf7b067cd0064418504f7f5295ef672"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#acaf7b067cd0064418504f7f5295ef672">RoundIndexRange</a> (const double begin, const double end, const double step, const bool closed=true, const bool unique=true)</td></tr>
<tr class="memdesc:acaf7b067cd0064418504f7f5295ef672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a range of index with double value rounded.  <a href="#acaf7b067cd0064418504f7f5295ef672">More...</a><br /></td></tr>
<tr class="separator:acaf7b067cd0064418504f7f5295ef672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe203d11c26bad3ecb17d46fc2ef36f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#affe203d11c26bad3ecb17d46fc2ef36f">BinHist</a> (const std::vector&lt; double &gt; &amp;dataset, const size_t n)</td></tr>
<tr class="memdesc:affe203d11c26bad3ecb17d46fc2ef36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commpute histogramm of dataset extended in <code>n</code> bins, bins are computes from <img class="formulaInl" alt="$[0;max]$" src="form_102.png"/> (values) to <img class="formulaInl" alt="$[0;n]$" src="form_103.png"/> (bins).  <a href="#affe203d11c26bad3ecb17d46fc2ef36f">More...</a><br /></td></tr>
<tr class="separator:affe203d11c26bad3ecb17d46fc2ef36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1349b73b463c3219fb70051b417afa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#acb1349b73b463c3219fb70051b417afa">FitDistribution</a> (const std::vector&lt; double &gt; &amp;values, double &amp;mu, double &amp;sigma, const std::vector&lt; double &gt; &amp;betas=<a class="el" href="namespace_geometry.html#a50ad7cbb8a04aeb2cf16fd13f85ee07d">doubleRange</a>(1.7, 3.5, 0.15), const double minQuant=0.022, const double maxQuant=0.60, const double minClean=0.250, const double maxDropout=0.10, const double stepBound=0.010, const double stepScale=0.01)</td></tr>
<tr class="memdesc:acb1349b73b463c3219fb70051b417afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a Fit distribution.  <a href="#acb1349b73b463c3219fb70051b417afa">More...</a><br /></td></tr>
<tr class="separator:acb1349b73b463c3219fb70051b417afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab220baebcbe814fe683a85050c3dd981"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_geometry.html#ab220baebcbe814fe683a85050c3dd981">sortedEigenVector</a> (const Eigen::MatrixXd &amp;matrix, Eigen::MatrixXd &amp;vectors, std::vector&lt; double &gt; &amp;values, const <a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5">EMetric</a> metric=<a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5aedca8775d78e240ca6902e89c60621bb">EMetric::Euclidian</a>)</td></tr>
<tr class="memdesc:ab220baebcbe814fe683a85050c3dd981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute sorted eigen vector of the matrix.  <a href="#ab220baebcbe814fe683a85050c3dd981">More...</a><br /></td></tr>
<tr class="separator:ab220baebcbe814fe683a85050c3dd981"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ac55ab4136356f33e78b9ec964767f29a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_geometry.html#ac55ab4136356f33e78b9ec964767f29a">Geometry::EAdaptations</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of Adaptation Methods for classifier. </p>
<hr/>
 <table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ac55ab4136356f33e78b9ec964767f29aa6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc">
<p>No Adaptation. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac55ab4136356f33e78b9ec964767f29aa1e67d6601e5c4a80ece61d4516427413"></a>Supervised&#160;</td><td class="fielddoc">
<p>Supervised Adaptation. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac55ab4136356f33e78b9ec964767f29aaeef6d82d4789990b23260ed94f46fa59"></a>Unsupervised&#160;</td><td class="fielddoc">
<p>Unsupervised Adaptation. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="abc5f0ced7932cbe299c3631735d6e9e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9">Geometry::EEstimator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of the covariance matrix estimator. Inspired by the work of Alexandre Barachant : <a href="https://github.com/alexandrebarachant/pyRiemann">pyRiemann</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="abc5f0ced7932cbe299c3631735d6e9e9a18448d7ac6e52fa9f9bb5861b0397b6e"></a>COV&#160;</td><td class="fielddoc">
<p>The Simple Covariance Estimator. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abc5f0ced7932cbe299c3631735d6e9e9a616842b667c02164dda634d846884093"></a>SCM&#160;</td><td class="fielddoc">
<p>The Normalized Spatial Covariance Matrix (SCM) Estimator. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abc5f0ced7932cbe299c3631735d6e9e9a19d4dcda54d9547a1195d4c793347219"></a>LWF&#160;</td><td class="fielddoc">
<p>The Ledoit and Wolf Estimator. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abc5f0ced7932cbe299c3631735d6e9e9aed16caa1a3469c82adfa26a6583ec15b"></a>OAS&#160;</td><td class="fielddoc">
<p>The Oracle Approximating Shrinkage (OAS) Estimator. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abc5f0ced7932cbe299c3631735d6e9e9a23d8bc2b33aa76cd40f661c9e181ef67"></a>MCD&#160;</td><td class="fielddoc">
<p>The Minimum Covariance Determinant (MCD) Estimator. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abc5f0ced7932cbe299c3631735d6e9e9ae928eee5ddbc4bf948a87749f9365980"></a>COR&#160;</td><td class="fielddoc">
<p>The Pearson Correlation Estimator. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abc5f0ced7932cbe299c3631735d6e9e9a581d6381f3f35e4f9d77201acf87b364"></a>IDE&#160;</td><td class="fielddoc">
<p>The Identity Matrix. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a41128205b080c60f7031983dd6cab9a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_geometry.html#a41128205b080c60f7031983dd6cab9a5">Geometry::EMatrixClassifiers</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><hr/>
 </p>
<hr/>
 <p>Enumeration of Matrix Classifiers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a41128205b080c60f7031983dd6cab9a5a1044ebd2843c1a9c4b9900135e706ba8"></a>MDM&#160;</td><td class="fielddoc">
<p>Minimum Distance To Mean (MDM) Classifier. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41128205b080c60f7031983dd6cab9a5a8fee10fd5c03e074d9faf9a72724b6d5"></a>MDM_Rebias&#160;</td><td class="fielddoc">
<p>Minimum Distance To Mean Rebias (MDM Rebias) Classifier. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41128205b080c60f7031983dd6cab9a5afde1ff9fb859e6eef3ebf11548d7b593"></a>FgMDM_RT&#160;</td><td class="fielddoc">
<p>Minimum Distance to Mean with geodesic filtering (FgMDM) (Real Time adaptation assumed). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41128205b080c60f7031983dd6cab9a5aadfbeada02d2a3dca176b4a7ff8cf1ca"></a>FgMDM&#160;</td><td class="fielddoc">
<p>Minimum Distance to Mean with geodesic filtering (FgMDM). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41128205b080c60f7031983dd6cab9a5a3fb59b48e2ac69b5218063d27ae32704"></a>FgMDM_RT_Rebias&#160;</td><td class="fielddoc">
<p>Minimum Distance to Mean with geodesic filtering &amp; Rebias adaptation (FgMDM Rebias) (Real Time adaptation assumed). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41128205b080c60f7031983dd6cab9a5ab49f68275acaafa375565eecb66eddaf"></a>FgMDM_Rebias&#160;</td><td class="fielddoc">
<p>Minimum Distance to Mean with geodesic filtering &amp; Rebias adaptation (FgMDM Rebias). </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ae7b2f142b97d4b99fa2327f29b9c5bf5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5">Geometry::EMetric</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of metrics. Inspired by the work of Alexandre Barachant : <a href="https://github.com/alexandrebarachant/pyRiemann">pyRiemann</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ae7b2f142b97d4b99fa2327f29b9c5bf5a61ea1974dd974297913b1fa2f0470d26"></a>Riemann&#160;</td><td class="fielddoc">
<p>The Riemannian Metric. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae7b2f142b97d4b99fa2327f29b9c5bf5aedca8775d78e240ca6902e89c60621bb"></a>Euclidian&#160;</td><td class="fielddoc">
<p>The Euclidian Metric. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae7b2f142b97d4b99fa2327f29b9c5bf5a2a1dfc1bc7b79fc5f5ee51e8e6ef1f95"></a>LogEuclidian&#160;</td><td class="fielddoc">
<p>The Log Euclidian Metric. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae7b2f142b97d4b99fa2327f29b9c5bf5a981ef655132b1c498b56608510008cba"></a>LogDet&#160;</td><td class="fielddoc">
<p>The Log Determinant Metric. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae7b2f142b97d4b99fa2327f29b9c5bf5a9ed1095d5cb5285b113fd9be6ca03f6c"></a>Kullback&#160;</td><td class="fielddoc">
<p>The Kullback Metric. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae7b2f142b97d4b99fa2327f29b9c5bf5a8785d2665b38ccc078c7086609c6a931"></a>ALE&#160;</td><td class="fielddoc">
<p>The AJD-based log-Euclidean (ALE) Metric. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae7b2f142b97d4b99fa2327f29b9c5bf5a9a0b88b2920076082bc28d827b18d9fb"></a>Harmonic&#160;</td><td class="fielddoc">
<p>The Harmonic Metric. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae7b2f142b97d4b99fa2327f29b9c5bf5af55d2253af03ad9dd88c01a3c3670fbc"></a>Wasserstein&#160;</td><td class="fielddoc">
<p>The Wasserstein Metric. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae7b2f142b97d4b99fa2327f29b9c5bf5ac9c5c65fb4af9cf90eb99b3b84424189"></a>Identity&#160;</td><td class="fielddoc">
<p>The Identity Metric. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a523d040f5c68154ee9e6647768d26841"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_geometry.html#a523d040f5c68154ee9e6647768d26841">Geometry::EStandardization</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of Standardization method for features matrix data. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a523d040f5c68154ee9e6647768d26841a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc">
<p>No change. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a523d040f5c68154ee9e6647768d26841a4f1f6016fc9f3f2353c0cc7c67b292bd"></a>Center&#160;</td><td class="fielddoc">
<p>Standardize data by removing the mean (on each feature separately). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a523d040f5c68154ee9e6647768d26841af93d9c0bb5d4d92fcc4a807b97d32aa6"></a>StandardScale&#160;</td><td class="fielddoc">
<p>Standardize data by removing the mean and scaling to unit variance (on each feature separately). </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aa36b39703f6c8ffe82046b27ec9deb91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd Geometry::AffineTransformation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply an affine transformation and return the result (The last transpose is useless if matrix is SPD). </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ B = R^{-1/2} * A * {R^{-1/2}}^{\mathsf{T}} \]" src="form_0.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>The reference matrix which transforms. </td></tr>
    <tr><td class="paramname">matrix</td><td>the matrix to transform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed matrix </dd></dl>

</div>
</div>
<a class="anchor" id="aed84358aabc6a65364775ad43294acc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::AJDPham </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>covs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>ajd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.0001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxIter</em> = <code>15</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Approximate Joint Diagonalization based on pham's algorithm.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_\text{AJD} = \cdots \]" src="form_68.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">covs</td><td>Vector of Covariance Matrix. </td></tr>
    <tr><td class="paramname">ajd</td><td>The computed Approximate Joint Diagonalization. </td></tr>
    <tr><td class="paramname">epsilon</td><td>(Optional) The epsilon. </td></tr>
    <tr><td class="paramname">maxIter</td><td>(Optional) The maximum iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Not implemented. </dd></dl>

</div>
</div>
<a class="anchor" id="a3167dfb6e8b2231624863605db9ba1de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; Geometry::ARange </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a href="https://numpy.org/doc/stable/reference/generated/numpy.arange.html">Numpy arange</a> implementation in C++. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Generic numeric type parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The start. </td></tr>
    <tr><td class="paramname">stop</td><td>The stop. </td></tr>
    <tr><td class="paramname">step</td><td>(Optional) Amount to increment by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector&lt;T&gt; </dd></dl>

</div>
</div>
<a class="anchor" id="a1f5c8b84af4038a25a249c5d99f21228"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::AreEquals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>matrix1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>matrix2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>precision</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check first the size, then if not empty matrix and then if they are almost equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix1</td><td>First Matrix. </td></tr>
    <tr><td class="paramname">matrix2</td><td>Second Matrix. </td></tr>
    <tr><td class="paramname">precision</td><td>Precision for matrix comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if the two elements are equals (with a precision tolerance), <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f266f0c56237ac3202d6047849c1ee3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::AreNotEmpty </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate if the vector is not empty and the matrices are validate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrices</td><td>Vector of Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0a48b66c4893ef1ac93d994ed6c9f33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::AreSquare </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate if the vector is not empty and the matrices are square matrix and not empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrices</td><td>Vector of Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="affe203d11c26bad3ecb17d46fc2ef36f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; Geometry::BinHist </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commpute histogramm of dataset extended in <code>n</code> bins, bins are computes from <img class="formulaInl" alt="$[0;max]$" src="form_102.png"/> (values) to <img class="formulaInl" alt="$[0;n]$" src="form_103.png"/> (bins). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset</td><td>Input vector (all datas are positive). </td></tr>
    <tr><td class="paramname">n</td><td>Number of bin of the final histogram. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2bef1676f0081a698038a646f8bcdfb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Geometry::Covariance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculation of the Covariance between two double dataset <img class="formulaInl" alt="$\vec{X}, \vec{Y}$" src="form_21.png"/>.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \operatorname{Cov}\left(x,y\right) = \frac{\sum_{i=1}^{N}{x_{i}y_{i}} - \left(\sum_{i=1}^{N}{x_{i}}\sum_{i=1}^{N}{y_{i}}\right)/N}{N}\]" src="form_22.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The dataset <img class="formulaInl" alt="$\vec{X}$" src="form_18.png"/>. With <img class="formulaInl" alt="$ N $" src="form_20.png"/> Samples. </td></tr>
    <tr><td class="paramname">y</td><td>The dataset <img class="formulaInl" alt="$\vec{Y}$" src="form_23.png"/>. With <img class="formulaInl" alt="$ N $" src="form_20.png"/> Samples. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Covariance. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3830d8f2116e6ab151ae9b7e142f855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::CovarianceMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9">EEstimator</a>&#160;</td>
          <td class="paramname"><em>estimator</em> = <code><a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9a18448d7ac6e52fa9f9bb5861b0397b6e">EEstimator::COV</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_geometry.html#a523d040f5c68154ee9e6647768d26841">EStandardization</a>&#160;</td>
          <td class="paramname"><em>standard</em> = <code><a class="el" href="namespace_geometry.html#a523d040f5c68154ee9e6647768d26841a4f1f6016fc9f3f2353c0cc7c67b292bd">EStandardization::Center</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select the function to call for the covariance matrix.<br />
</p>
<ul>
<li>centralizing the data is useless for <code><a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9a18448d7ac6e52fa9f9bb5861b0397b6e" title="The Simple Covariance Estimator. ">EEstimator::COV</a></code> and <code><a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9ae928eee5ddbc4bf948a87749f9365980" title="The Pearson Correlation Estimator. ">EEstimator::COR</a></code>.<br />
</li>
<li>centralizing the data is not usual for <code><a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9a616842b667c02164dda634d846884093" title="The Normalized Spatial Covariance Matrix (SCM) Estimator. ">EEstimator::SCM</a></code>. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The dataset <img class="formulaInl" alt="$\vec{X}$" src="form_18.png"/>. With <img class="formulaInl" alt="$ N $" src="form_20.png"/> Rows (features) and <img class="formulaInl" alt="$ S $" src="form_12.png"/> columns (samples). </td></tr>
    <tr><td class="paramname">out</td><td>The Covariance Matrix. </td></tr>
    <tr><td class="paramname">estimator</td><td>(Optional) The selected estimator (see <a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9" title="Enumeration of the covariance matrix estimator. Inspired by the work of Alexandre Barachant : pyRiema...">EEstimator</a>). </td></tr>
    <tr><td class="paramname">standard</td><td>(Optional) Standardize the data (see <a class="el" href="namespace_geometry.html#a523d040f5c68154ee9e6647768d26841" title="Enumeration of Standardization method for features matrix data. ">EStandardization</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8410e9e47cdfecb0e34522dae71271ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::CovarianceMatrixCOR </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>cov</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculation of the covariance matrix by the method : Pearson Correlation.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ M_{\operatorname{Cov_{COR}}}\left(i,j\right) = \frac{ M_{\operatorname{Cov}}\left(i,j\right) } { \sqrt{ M_{\operatorname{Cov}}\left(i,i\right) * M_{\operatorname{Cov}}\left(j,j\right) } } \]" src="form_34.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samples</td><td>The dataset <img class="formulaInl" alt="$\vec{X}$" src="form_18.png"/>. With <img class="formulaInl" alt="$ N $" src="form_20.png"/> Rows (features) and <img class="formulaInl" alt="$ S $" src="form_12.png"/> columns (samples). </td></tr>
    <tr><td class="paramname">cov</td><td>The Covariance Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a28b74ff6628bef643a5d49615f3ec374"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::CovarianceMatrixCOV </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>cov</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculation of the covariance matrix.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ M_{\operatorname{Cov}} = \begin{pmatrix} V\left(x_1\right) &amp; \operatorname{Cov}\left(x_1,x_2\right) &amp;\cdots &amp; \operatorname{Cov}\left(x_1,x_N\right)\\ \operatorname{Cov}\left(x_2,x_1\right) &amp;\ddots &amp; \ddots &amp; \vdots \\ \vdots &amp; \ddots &amp; \ddots &amp; \vdots \\ \operatorname{Cov}\left(x_N,x_1\right) &amp;\cdots &amp; \cdots &amp; V\left(x_N\right) \end{pmatrix} \quad\quad \text{with } x_i \text{ the feature } i \]" src="form_27.png"/>
</p>
<p><br />
With the <a class="el" href="namespace_geometry.html#a91b0a15045364dad7728f02677c1051c" title="Calculation of the Variance of a double dataset .   ">Variance</a> and <a class="el" href="namespace_geometry.html#a2bef1676f0081a698038a646f8bcdfb5" title="Calculation of the Covariance between two double dataset .   ">Covariance</a> function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samples</td><td>The dataset <img class="formulaInl" alt="$\vec{X}$" src="form_18.png"/>. With <img class="formulaInl" alt="$ N $" src="form_20.png"/> Rows (features) and <img class="formulaInl" alt="$ S $" src="form_12.png"/> columns (samples). </td></tr>
    <tr><td class="paramname">cov</td><td>The Covariance Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5eeeb52e92fbdc25eb16d31bf0450a2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::CovarianceMatrixIDE </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>cov</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the Identity matrix <img class="formulaInl" alt="$ I_N $" src="form_35.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samples</td><td>The dataset <img class="formulaInl" alt="$\vec{X}$" src="form_18.png"/>. With <img class="formulaInl" alt="$ N $" src="form_20.png"/> Rows (features) and <img class="formulaInl" alt="$ S $" src="form_12.png"/> columns (samples). </td></tr>
    <tr><td class="paramname">cov</td><td>The Covariance Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a785aaaaed209dd8b3f674d4474897feb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::CovarianceMatrixLWF </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>cov</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculation of the covariance matrix and shrinkage by the method : Ledoit and Wolf.<br />
</p><ol type="1">
<li>Compute the Covariance Matrix (see <a class="el" href="namespace_geometry.html#a28b74ff6628bef643a5d49615f3ec374" title="Calculation of the covariance matrix.   With the Variance and Covariance function. ">CovarianceMatrixCOV</a>) <img class="formulaInl" alt="$ M_{\operatorname{Cov}} $" src="form_29.png"/></li>
<li>Compute the Ledoit and Wolf Shrinkage</li>
<li>Shrunk the Matrix (see <a class="el" href="namespace_geometry.html#a3c58e4b585bd4636bc884fe179edc415" title="Shrunks the Covariance Matrix  (destructive operation).   ">ShrunkCovariance</a>) </li>
</ol>
</p>
<p>Ledoit and Wolf Shrinkage (from <a href="http://scikit-learn.org/stable/modules/generated/sklearn.covariance.LedoitWolf.html">Sklearn LedoitWolf Estimator</a>) described in "A Well-Conditioned Estimator for Large-Dimensional Covariance Matrices", Ledoit and Wolf, Journal of Multivariate Analysis, Volume 88, Issue 2, February 2004, pages 365-411. : <br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{aligned} \vec{X}^2 &amp;= \begin{pmatrix}x_{0,0}^2 &amp; \cdots &amp; x_{0,S}^2 \\ \vdots &amp; \ddots &amp;\vdots \\ x_{N,0}^2 &amp; \cdots &amp; x_{N,S}^2\end{pmatrix} \quad \text{with } x_{i,j} \in \vec{X}\\ M_{\mu} &amp;= \mu\times I_N = \begin{pmatrix} \mu &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; \ddots &amp;\ddots &amp; \vdots \\ \vdots &amp; \ddots &amp;\ddots &amp; 0 \\ 0 &amp; \cdots &amp; 0 &amp; \mu\end{pmatrix} \quad \text{with } \mu = \frac{\operatorname{trace}(M_{\operatorname{Cov}})}{N}\\ M_{\delta} &amp;= M_{\operatorname{Cov}}-M_{\mu}\\ M_{\delta}^2 &amp;= M_{\delta} * M_{\delta}\\ M_{\beta} &amp;= \frac{1}{S} \times \left(\vec{X}^2 * \vec{X}^{2\mathsf{T}}\right) - M_{Cov} * M_{Cov}\\ \Sigma\left( M \right) &amp;=\text{ the sum of the elements of the matrix } M\\ \end{aligned} \]" src="form_30.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \text{Shrinkage}_\text{LWF} = \frac{\beta}{\delta} \quad \text{with } \delta = \frac{\Sigma\left( M_{\delta}^2 \right)}{N} \quad\text{and}\quad \beta = \operatorname{min}\left(\frac{\Sigma\left( M_{\beta}^2 \right)}{N \times S},~ \delta\right)\]" src="form_31.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samples</td><td>The dataset <img class="formulaInl" alt="$\vec{X}$" src="form_18.png"/>. With <img class="formulaInl" alt="$ N $" src="form_20.png"/> Rows (features) and <img class="formulaInl" alt="$ S $" src="form_12.png"/> columns (samples). </td></tr>
    <tr><td class="paramname">cov</td><td>The Covariance Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac53c7c9a08cd380bbcb3cd73158ff446"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::CovarianceMatrixMCD </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>cov</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculation of the covariance matrix and shrinkage by the method : Minimum Covariance Determinant (MCD). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samples</td><td>The dataset <img class="formulaInl" alt="$\vec{X}$" src="form_18.png"/>. With <img class="formulaInl" alt="$ N $" src="form_20.png"/> Rows (features) and <img class="formulaInl" alt="$ S $" src="form_12.png"/> columns (samples). </td></tr>
    <tr><td class="paramname">cov</td><td>The Covariance Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Not implemented. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ddcc48b45d074b7c38e76632517353e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::CovarianceMatrixOAS </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>cov</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculation of the covariance matrix and shrinkage by the method : Oracle Approximating Shrinkage (OAS).<br />
</p><ol type="1">
<li>Compute the Covariance Matrix (see <a class="el" href="namespace_geometry.html#a28b74ff6628bef643a5d49615f3ec374" title="Calculation of the covariance matrix.   With the Variance and Covariance function. ">CovarianceMatrixCOV</a>) <img class="formulaInl" alt="$ M_{\operatorname{Cov}} $" src="form_29.png"/></li>
<li>Compute the Oracle Approximating Shrinkage</li>
<li>Shrunk the Matrix (see <a class="el" href="namespace_geometry.html#a3c58e4b585bd4636bc884fe179edc415" title="Shrunks the Covariance Matrix  (destructive operation).   ">ShrunkCovariance</a>) </li>
</ol>
</p>
<p>Oracle Approximating Shrinkage (from <a href="http://scikit-learn.org/stable/modules/generated/sklearn.covariance.OAS.html">Sklearn Oracle Approximating Shrinkage Estimator</a>) describe in "Shrinkage Algorithms for MMSE Covariance Estimation" Chen et al., IEEE Trans. on Sign. Proc., Volume 58, Issue 10, October 2010. : <br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{aligned} \mu &amp;= \frac{\operatorname{trace}(M_{\operatorname{Cov}})}{N}\\ \mu \left( M \right) &amp;=\text{ the mean of the elements of the matrix } M\\ \alpha &amp;= \mu \left( M_{\operatorname{Cov}} * M_{\operatorname{Cov}} \right)\\ \text{num} &amp;= \alpha + \mu^2\\ \text{den} &amp;= (S + 1) \times \frac{\alpha - \mu^2}{N}\\ \end{aligned} \]" src="form_32.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \text{Shrinkage}_\text{OAS} = \begin{cases} 1, &amp; \text{if}\ \text{den} = 0 \text{ or num} &gt; \text{den} \\ \frac{\text{num}}{\text{den}}, &amp; \text{otherwise} \end{cases} \]" src="form_33.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samples</td><td>The dataset <img class="formulaInl" alt="$\vec{X}$" src="form_18.png"/>. With <img class="formulaInl" alt="$ N $" src="form_20.png"/> Rows (features) and <img class="formulaInl" alt="$ S $" src="form_12.png"/> columns (samples). </td></tr>
    <tr><td class="paramname">cov</td><td>The Covariance Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a99669e1e1c24331620421be90927f834"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::CovarianceMatrixSCM </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>cov</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculation of the covariance matrix by the method : Normalized Spatial Covariance Matrix (SCM).<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ M_{\operatorname{Cov_{SCM}}} = \frac{XX^{\mathsf{T}}}{\operatorname{trace}{\left(XX^{\mathsf{T}}\right)}} \]" src="form_28.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samples</td><td>The dataset <img class="formulaInl" alt="$\vec{X}$" src="form_18.png"/>. With <img class="formulaInl" alt="$ N $" src="form_20.png"/> Rows (features) and <img class="formulaInl" alt="$ S $" src="form_12.png"/> columns (samples). </td></tr>
    <tr><td class="paramname">cov</td><td>The Covariance Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa086d103988d1765494604ea8f00ecc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Geometry::Distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5">EMetric</a>&#160;</td>
          <td class="paramname"><em>metric</em> = <code><a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5a61ea1974dd974297913b1fa2f0470d26">EMetric::Riemann</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the distance between two matrix with the selected <code>metric</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The First Covariance matrix. </td></tr>
    <tr><td class="paramname">b</td><td>The Second Covariance matrix. </td></tr>
    <tr><td class="paramname">metric</td><td>(Optional) The metric (see <a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5" title="Enumeration of metrics. Inspired by the work of Alexandre Barachant : pyRiemann. ">EMetric</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Distance between A and B. </dd></dl>

</div>
</div>
<a class="anchor" id="a9360b11584fe2e5126e7fb2f440ef9f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Geometry::DistanceEuclidian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Euclidian Distance between two covariance matrices A and B.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ d_{\text{E}}(A,B) = \left\lVert B - A \right\rVert\]" src="form_40.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The First Covariance matrix. </td></tr>
    <tr><td class="paramname">b</td><td>The Second Covariance matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Eclidean Distance between A and B. </dd></dl>

</div>
</div>
<a class="anchor" id="acac13e624230cda19d4d59b711b8a763"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Geometry::DistanceKullback </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Kullback Leibler Divergence between two covariance matrices A and B.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ d_{\text{K}}(A,B) = 0.5 \times \left( \operatorname{trace}\left(B^{-1} ~ A\right) - N + \log\left( \frac{\left\lvert B \right\rvert }{\left\lvert A \right\rvert} \right) \right) \]" src="form_44.png"/>
</p>
<p> with : <img class="formulaInl" alt="$\left\lvert A \right\rvert$" src="form_43.png"/> the determinant of <img class="formulaInl" alt="$A$" src="form_38.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The First Covariance matrix. </td></tr>
    <tr><td class="paramname">b</td><td>The Second Covariance matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Kullback Leibler Divergence Distance between A and B. </dd></dl>

</div>
</div>
<a class="anchor" id="a48c059c124f49eced60836607b6952d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Geometry::DistanceKullbackSym </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Symetric Kullback Leibler Divergence between two covariance matrices A and B.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ d_{\text{sK}}(A,B) = d_\text{K}(A, B) + d_\text{K}(B, A) \]" src="form_45.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The First Covariance matrix. </td></tr>
    <tr><td class="paramname">b</td><td>The Second Covariance matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Symetric Kullback Leibler Divergence Distance between A and B. </dd></dl>

</div>
</div>
<a class="anchor" id="ad704a591f9f0144d0397420a8efb619c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Geometry::DistanceLogDet </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Log-det Distance between two covariance matrices A and B.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ d_{\text{lD}}(A,B) = \sqrt{\log\left(\left\lvert\frac{A + B}{2}\right\rvert\right) - 0.5 \times \log\left( \left\lvert A \right\rvert \times \left\lvert B \right\rvert \right)} \]" src="form_42.png"/>
</p>
<p> with : <img class="formulaInl" alt="$\left\lvert A \right\rvert$" src="form_43.png"/> the determinant of <img class="formulaInl" alt="$A$" src="form_38.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The First Covariance matrix. </td></tr>
    <tr><td class="paramname">b</td><td>The Second Covariance matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Log-det Distance between A and B. </dd></dl>

</div>
</div>
<a class="anchor" id="af4e2aebdd4acb2c42ee28f20b692b00b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Geometry::DistanceLogEuclidian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Log Euclidian Distance between two covariance matrices A and B.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ d_{\text{lE}}(A,B) = \left\lVert \log\left(B\right) - \log\left(A\right) \right\rVert\]" src="form_41.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The First Covariance matrix. </td></tr>
    <tr><td class="paramname">b</td><td>The Second Covariance matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Log Eclidean Distance between A and B. </dd></dl>

</div>
</div>
<a class="anchor" id="a21f3b2ed8219ca2f1cce0791a0ff4179"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Geometry::DistanceRiemann </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Riemannian Distance between two covariance matrices A and B.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ d_{\text{R}}(A,B) = \sqrt{\left( \sum_i \log\left(\lambda_i\right)^2 \right)} \]" src="form_36.png"/>
</p>
<p> with : <img class="formulaInl" alt="$\lambda_i$" src="form_37.png"/> the joint eigenvalues of <img class="formulaInl" alt="$A$" src="form_38.png"/> and <img class="formulaInl" alt="$B$" src="form_39.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The First Covariance matrix. </td></tr>
    <tr><td class="paramname">b</td><td>The Second Covariance matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Riemannian Distance between A and B. </dd></dl>

</div>
</div>
<a class="anchor" id="ad29b8ac52fdde0633b37bc36378caa86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Geometry::DistanceWasserstein </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Wasserstein Distance between two covariance matrices A and B.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ d_{\text{W}}(A,B) = \sqrt{ \operatorname{trace}\left(A + B - 2 \times \left(A^{1/2} ~ B ~ A^{1/2}\right)^{1/2}\right) } \]" src="form_46.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The First Covariance matrix. </td></tr>
    <tr><td class="paramname">b</td><td>The Second Covariance matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Wasserstein Distance between A and B. </dd></dl>

</div>
</div>
<a class="anchor" id="a50ad7cbb8a04aeb2cf16fd13f85ee07d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; Geometry::doubleRange </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>step</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>closed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a range of double value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Begin of the range. </td></tr>
    <tr><td class="paramname">end</td><td>End of the range. </td></tr>
    <tr><td class="paramname">step</td><td>Step of the range. </td></tr>
    <tr><td class="paramname">closed</td><td>Autorize the end in range if <code>True</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The range vector. </dd></dl>
<p>Use <a href="https://en.cppreference.com/w/cpp/algorithm/iota">std::iota</a> function and a struct for this specific used. </p>

</div>
</div>
<a class="anchor" id="a8cd3153028daa58925ba9ebe442b9ef4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::Featurization </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tangent</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>ref</em> = <code>Eigen::MatrixXd()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the features vector of covariance matrix with the selected method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The covariance in. </td></tr>
    <tr><td class="paramname">out</td><td>The Feature Vector. </td></tr>
    <tr><td class="paramname">tangent</td><td>(Optional) True to use tangent space featurization, Upper Triangle Squeeze if false. </td></tr>
    <tr><td class="paramname">ref</td><td>The reference Matrix (usefull for Tangent Space Featurization). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a4cd0253cdf114b5cd67e2db5e65f70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::FgDAApply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the weight on the vector. (just a matrix product) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Sample to transform. </td></tr>
    <tr><td class="paramname">out</td><td>Transformed Sample. </td></tr>
    <tr><td class="paramname">weight</td><td>The Weight to apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>
<p>Method inspired by the work of Alexandre Barachant : <a href="https://github.com/alexandrebarachant/pyRiemann">pyRiemann</a> (<a href="https://github.com/alexandrebarachant/pyRiemann/blob/master/LICENSE">License</a>). </p>

</div>
</div>
<a class="anchor" id="a1a23032aa1f2ef3efa9a93f079952362"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::FgDACompute </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Eigen::RowVectorXd &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>datasets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Least squares (LSQR) Weight and transform to FgDA Weight. <br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ W_{\text{FgDA}} = W^{\mathsf{T}} \times (W \times W^{\mathsf{T}})^{-1} \times W \]" src="form_3.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">datasets</td><td>The data set one class by row and trials on colums. </td></tr>
    <tr><td class="paramname">weight</td><td>The Weight to apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>
<p>Method inspired by the work of Alexandre Barachant : <a href="https://github.com/alexandrebarachant/pyRiemann">pyRiemann</a> (<a href="https://github.com/alexandrebarachant/pyRiemann/blob/master/LICENSE">License</a>). </p>

</div>
</div>
<a class="anchor" id="acb1349b73b463c3219fb70051b417afa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::FitDistribution </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>betas</em> = <code><a class="el" href="namespace_geometry.html#a50ad7cbb8a04aeb2cf16fd13f85ee07d">doubleRange</a>(1.7,&#160;3.5,&#160;0.15)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>minQuant</em> = <code>0.022</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>maxQuant</em> = <code>0.60</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>minClean</em> = <code>0.250</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>maxDropout</em> = <code>0.10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>stepBound</em> = <code>0.010</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>stepScale</em> = <code>0.01</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a Fit distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>The values. </td></tr>
    <tr><td class="paramname">mu</td><td>The mu. </td></tr>
    <tr><td class="paramname">sigma</td><td>The sigma. </td></tr>
    <tr><td class="paramname">betas</td><td>List of wanted <img class="formulaInl" alt="$\beta$" src="form_104.png"/> shapes. </td></tr>
    <tr><td class="paramname">minQuant</td><td>Minimum of wanted quantile. </td></tr>
    <tr><td class="paramname">maxQuant</td><td>Maximum of wanted quantile. </td></tr>
    <tr><td class="paramname">minClean</td><td>Minimum of estimated clean datas. </td></tr>
    <tr><td class="paramname">maxDropout</td><td>Maximum of estimated artifact datas. </td></tr>
    <tr><td class="paramname">stepBound</td><td>Step used to select beginning of datas subset. </td></tr>
    <tr><td class="paramname">stepScale</td><td>Step used to select size of datas subset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a7bdc496eb1d5ad2132f01fea8e34b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::Geodesic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5">EMetric</a>&#160;</td>
          <td class="paramname"><em>metric</em> = <code><a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5a61ea1974dd974297913b1fa2f0470d26">EMetric::Riemann</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the matrix at the position alpha on the geodesic between A and B with the selected <code>metric</code>.<br />
</p>
<ul>
<li>Allowed Metrics : <code>Riemann</code>, <code>Euclidian</code>, <code>LogEuclidian</code>, <code>Identity</code> </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The First Covariance matrix. </td></tr>
    <tr><td class="paramname">b</td><td>The Second Covariance matrix. </td></tr>
    <tr><td class="paramname">g</td><td>The Geodesic. </td></tr>
    <tr><td class="paramname">metric</td><td>(Optional) The metric (see <a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5" title="Enumeration of metrics. Inspired by the work of Alexandre Barachant : pyRiemann. ">EMetric</a>). </td></tr>
    <tr><td class="paramname">alpha</td><td>(Optional) Position on the Geodesic : <img class="formulaInl" alt="$ 0\leq \text{alpha} \leq 1$" src="form_62.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2adb606bd7e956a6d4377ae0210ff08e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::GeodesicEuclidian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the matrix at the position alpha on the Euclidean geodesic between A and B.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \gamma_\text{E} = \left(1 - \alpha \right) \times A + \alpha \times B \]" src="form_64.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The First Covariance matrix. </td></tr>
    <tr><td class="paramname">b</td><td>The Second Covariance matrix. </td></tr>
    <tr><td class="paramname">g</td><td>The Geodesic. </td></tr>
    <tr><td class="paramname">alpha</td><td>(Optional) Position on the Geodesic : <img class="formulaInl" alt="$ 0\leq \text{alpha} \leq 1$" src="form_62.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ed64c08ac404aa639686e06d9ae30f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::GeodesicIdentity </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the matrix at the position alpha on the Identity geodesic. <br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \gamma_\text{I} = I_N \]" src="form_66.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The First Covariance matrix. </td></tr>
    <tr><td class="paramname">b</td><td>The Second Covariance matrix. </td></tr>
    <tr><td class="paramname">g</td><td>The Geodesic. </td></tr>
    <tr><td class="paramname">alpha</td><td>(Optional) Position on the Geodesic : <img class="formulaInl" alt="$ 0\leq \text{alpha} \leq 1$" src="form_62.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3da82ed68dccc3a8fa0c0d279ffc60f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::GeodesicLogEuclidian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the matrix at the position alpha on the Log Euclidean geodesic between A and B. <br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \gamma_\text{LogE} = \exp\left(\left(1 - \alpha \right) \times \log\left(A\right) + \alpha \times \log\left(B\right) \right)\]" src="form_65.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The First Covariance matrix. </td></tr>
    <tr><td class="paramname">b</td><td>The Second Covariance matrix. </td></tr>
    <tr><td class="paramname">g</td><td>The Geodesic. </td></tr>
    <tr><td class="paramname">alpha</td><td>(Optional) Position on the Geodesic : <img class="formulaInl" alt="$ 0\leq \text{alpha} \leq 1$" src="form_62.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a94dbac25b3eb3e105086fbf365b3fc4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::GeodesicRiemann </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the matrix at the position alpha on the Riemannian geodesic between A and B. <br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \gamma_\text{R} = A^{1/2} ~ \left( A^{-1/2} ~ B ~ A^{-1/2} \right)^\alpha ~ A^{1/2} \]" src="form_63.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The First Covariance matrix. </td></tr>
    <tr><td class="paramname">b</td><td>The Second Covariance matrix. </td></tr>
    <tr><td class="paramname">g</td><td>The Geodesic. </td></tr>
    <tr><td class="paramname">alpha</td><td>(Optional) Position on the Geodesic : <img class="formulaInl" alt="$ 0\leq \text{alpha} \leq 1$" src="form_62.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1790223ebc2517a6dd2a6125648e7911"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::RowVectorXd Geometry::GetElements </td>
          <td>(</td>
          <td class="paramtype">const Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the items selected by the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the original row. </td></tr>
    <tr><td class="paramname">index</td><td>Elements to select. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Row with selected elements. </dd></dl>

</div>
</div>
<a class="anchor" id="aa271733266d4835c65c91ec6ba43cf8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::HaveSameSize </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates if two matrix have same size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Matrix A. </td></tr>
    <tr><td class="paramname">b</td><td>Matrix B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab97072006bdb184db6a3a34fd07a6e2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::HaveSameSize </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate if the vector is not empty and the matrices have same size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrices</td><td>Vector of Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e3b63720382fdec12165aab53b0cefd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::InRange </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate if value is in [min;max]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value. </td></tr>
    <tr><td class="paramname">min</td><td>The minimum. </td></tr>
    <tr><td class="paramname">max</td><td>The maximum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab72070c0b521b34cd06132319e29e5e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::IsNotEmpty </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates if matrix is not empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9ff7acbbbafd70cbd42a6c3bbf4b088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::IsSquare </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates if matrix is square matrix and not empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5abe51bb1f564f1d2004115f7e428ed9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::LSQR </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Eigen::RowVectorXd &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>datasets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the weight of Linear Discriminant Analysis with Least squares (LSQR) Solver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">datasets</td><td>The datasets one class by row and trials on colums. </td></tr>
    <tr><td class="paramname">weight</td><td>The wight to apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>
<p>Inspired by <a href="http://scikit-learn.org">sklearn</a> <a href="https://scikit-learn.org/stable/modules/generated/sklearn.discriminant_analysis.LinearDiscriminantAnalysis.html">LinearDiscriminantAnalysis</a> (<a href="https://github.com/scikit-learn/scikit-learn/blob/master/COPYING">License</a>). </p>

</div>
</div>
<a class="anchor" id="a03ca5a71291053eafff937512072328a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::MatrixCenter </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the mean of each row at the matrix (destructive operation).<br />
So <img class="formulaInl" alt="$\mu=0$" src="form_1.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The Matrix to center. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="afde10cd924c56e050900d8d8967a44ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::MatrixCenter </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the mean of each row at the matrix (non destructive operation).<br />
So <img class="formulaInl" alt="$\mu=0$" src="form_1.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The Matrix to center. </td></tr>
    <tr><td class="paramname">out</td><td>The Matrix centered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aef7bc24b1b6807aef5a10d0a4c2e78e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Geometry::MatrixPrint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give the string format of Matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The Matrix to display. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string format. </dd></dl>

</div>
</div>
<a class="anchor" id="a21026f164262c111902f3bd7de7e4222"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::MatrixStandardization </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_geometry.html#a523d040f5c68154ee9e6647768d26841">EStandardization</a>&#160;</td>
          <td class="paramname"><em>standard</em> = <code><a class="el" href="namespace_geometry.html#a523d040f5c68154ee9e6647768d26841a6adf97f83acf6453d4a6a4b1070f3754">EStandardization::None</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standardize data row by row with selected method (destructive operation). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix to standardize. </td></tr>
    <tr><td class="paramname">standard</td><td>Standard method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a822bff91b5d2d1e41bf6e29552b72b12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::MatrixStandardization </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_geometry.html#a523d040f5c68154ee9e6647768d26841">EStandardization</a>&#160;</td>
          <td class="paramname"><em>standard</em> = <code><a class="el" href="namespace_geometry.html#a523d040f5c68154ee9e6647768d26841a6adf97f83acf6453d4a6a4b1070f3754">EStandardization::None</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standardize data row by row with selected method (non destructive operation). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The matrix to standardize. </td></tr>
    <tr><td class="paramname">out</td><td>The matrix standardized. </td></tr>
    <tr><td class="paramname">standard</td><td>Standard method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abae67252afea0dc9ee1751460660b83d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::MatrixStandardScaler </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the mean of each row at the matrix and divide by the variance (destructive operation with scale return).<br />
So <img class="formulaInl" alt="$\mu=0$" src="form_1.png"/> and <img class="formulaInl" alt="$\sigma=1$" src="form_2.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The Matrix to standardize. </td></tr>
    <tr><td class="paramname">scale</td><td>The scale vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>
<p>Adaptation of <a href="http://scikit-learn.org">sklearn</a> <a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html">StandardScaler</a> (<a href="https://github.com/scikit-learn/scikit-learn/blob/master/COPYING">License</a>). </p>

</div>
</div>
<a class="anchor" id="abe288564e75be68b6ed689a602de6b1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::MatrixStandardScaler </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the mean of each row at the matrix and divide by the variance (destructive operation).<br />
So <img class="formulaInl" alt="$\mu=0$" src="form_1.png"/> and <img class="formulaInl" alt="$\sigma=1$" src="form_2.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The Matrix to standardize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>
<p>Adaptation of <a href="http://scikit-learn.org">sklearn</a> <a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html">StandardScaler</a> (<a href="https://github.com/scikit-learn/scikit-learn/blob/master/COPYING">License</a>). </p>

</div>
</div>
<a class="anchor" id="a484f6f740b108fb7929fd5fa3fe59d1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::MatrixStandardScaler </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the mean of each row at the matrix and divide by the variance (non destructive operation with scale return).<br />
So <img class="formulaInl" alt="$\mu=0$" src="form_1.png"/> and <img class="formulaInl" alt="$\sigma=1$" src="form_2.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The Matrix to standardize. </td></tr>
    <tr><td class="paramname">out</td><td>The Matrix standardized. </td></tr>
    <tr><td class="paramname">scale</td><td>The scale vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>
<p>Adaptation of <a href="http://scikit-learn.org">sklearn</a> <a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html">StandardScaler</a> (<a href="https://github.com/scikit-learn/scikit-learn/blob/master/COPYING">License</a>). </p>

</div>
</div>
<a class="anchor" id="a53e78afbb2bda9aebc6c63eb685ebd19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::MatrixStandardScaler </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the mean of each row at the matrix and divide by the variance (non destructive operation).<br />
So <img class="formulaInl" alt="$\mu=0$" src="form_1.png"/> and <img class="formulaInl" alt="$\sigma=1$" src="form_2.png"/>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The Matrix to standardize. </td></tr>
    <tr><td class="paramname">out</td><td>The Matrix standardized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>
<p>Adaptation of <a href="http://scikit-learn.org">sklearn</a> <a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html">StandardScaler</a> (<a href="https://github.com/scikit-learn/scikit-learn/blob/master/COPYING">License</a>). </p>

</div>
</div>
<a class="anchor" id="a18f34ce11b4949cd50f85eb750f6d525"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::Mean </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>covs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5">EMetric</a>&#160;</td>
          <td class="paramname"><em>metric</em> = <code><a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5a61ea1974dd974297913b1fa2f0470d26">EMetric::Riemann</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean of vector of covariance matrix with the selected <code>metric</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">covs</td><td>Vector of Covariance Matrix. </td></tr>
    <tr><td class="paramname">mean</td><td>The computed mean. </td></tr>
    <tr><td class="paramname">metric</td><td>(Optional) The metric (see <a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5" title="Enumeration of metrics. Inspired by the work of Alexandre Barachant : pyRiemann. ">EMetric</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a93ad24df7d60542554c7902e0b2ef85c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::MeanALE </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>covs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>mean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Approximate joint diagonalization based log-Euclidean (ALE) Mean. <br />
</p><ol type="1">
<li>Compute the Approximate Joint Diagonalization <img class="formulaInl" alt="$ C_\text{AJD} $" src="form_88.png"/> (see <a class="el" href="namespace_geometry.html#aed84358aabc6a65364775ad43294acc5" title="Approximate Joint Diagonalization based on pham&#39;s algorithm.   ">AJDPham</a>)</li>
<li>Update with an iterative procedure that stops after 50 iterations or when criterion is under <img class="formulaInl" alt="$ 10^{-4}$" src="form_70.png"/> </li>
</ol>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_{\mu_\text{ALE}} = C_\text{AJD}\]" src="form_89.png"/>
</p>
<p> Iterative process with <img class="formulaInl" alt="$J$" src="form_72.png"/> (and <img class="formulaInl" alt="$U = \operatorname{diag}(\operatorname{diag}(\exp(J))$" src="form_90.png"/>) while <img class="formulaInl" alt="$ \text{iteration} &lt; 50 $" src="form_73.png"/> and <img class="formulaInl" alt="$ 10^{-4} &lt; d_\text{R}(I_N,U) $" src="form_91.png"/> </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{aligned} J &amp;= \frac{1}{N} \log\left(\sum_i \left( C_{\mu_\text{ALE}}^{\mathsf{T}} C_i C_{\mu_\text{ALE}} \right) \right)\\ U &amp;= \operatorname{diag}(\operatorname{diag}(\exp(J))\\ C_{\mu_\text{ALE}} &amp;= C_{\mu_\text{ALE}} * U^{-1/2}\\ \end{aligned}\]" src="form_92.png"/>
</p>
<p> After the Iterative process : </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{aligned} J &amp;= \frac{1}{N} \log\left(\sum_i \left( C_{\mu_\text{ALE}}^{\mathsf{T}} C_i C_{\mu_\text{ALE}} \right) \right)\\ C_{\mu_\text{ALE}} &amp;= \left(C_{\mu_\text{ALE}}^{-1}\right)^{\mathsf{T}} ~ \exp(J) ~ C_{\mu_\text{ALE}}^{-1} \end{aligned}\]" src="form_93.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">covs</td><td>Vector of Covariance Matrix. </td></tr>
    <tr><td class="paramname">mean</td><td>The mean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Doesn't work =&gt; Need to implement <a class="el" href="namespace_geometry.html#aed84358aabc6a65364775ad43294acc5" title="Approximate Joint Diagonalization based on pham&#39;s algorithm.   ">AJDPham</a> and check if it works next. </dd></dl>

</div>
</div>
<a class="anchor" id="a2abb6c24f0a2eb4ccd89a7ecef5d7a28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::MeanEuclidian </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>covs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>mean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Euclidian Mean.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_{\mu_\text{E}} =\frac{1}{N} \sum_i{C_i}\]" src="form_78.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">covs</td><td>Vector of Covariance Matrix. </td></tr>
    <tr><td class="paramname">mean</td><td>The mean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a862eacff8d80037b931e71c5d096754a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::MeanHarmonic </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>covs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>mean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Harmonic Mean.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_{\mu_\text{H}} = (\frac{1}{N} \sum_i{C_i}^{-1})^{-1} \]" src="form_94.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">covs</td><td>Vector of Covariance Matrix. </td></tr>
    <tr><td class="paramname">mean</td><td>The mean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a54656e27a1e7aedb6597a3f836fc1caa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::MeanIdentity </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>covs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>mean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give the Identity Matrix.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_{\mu_\text{I}} = I_N \]" src="form_95.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">covs</td><td>Vector of Covariance Matrix. </td></tr>
    <tr><td class="paramname">mean</td><td>The mean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aae1cc6a45cc9f90f04d5f4665d884a2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::MeanKullback </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>covs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>mean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Kullback Mean.<br />
The mean is the Geodesic center between the Euclidian and the Harmonic Mean.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_{\mu_\text{K}} = \gamma \left( C_{\mu_{\text{E}}}, C_{\mu_{\text{H}}} \right) \]" src="form_83.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">covs</td><td>Vector of Covariance Matrix. </td></tr>
    <tr><td class="paramname">mean</td><td>The mean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b3f50490006a6ee3fe513f067f56e5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::MeanLogDet </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>covs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>mean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Log Determinant Mean.<br />
</p><ol type="1">
<li>Compute the Classical Mean <img class="formulaInl" alt="$ C_{\mu_\text{E}} $" src="form_69.png"/> (see <a class="el" href="namespace_geometry.html#a2abb6c24f0a2eb4ccd89a7ecef5d7a28" title="Compute the Euclidian Mean.   ">MeanEuclidian</a>)</li>
<li>Update with an iterative procedure that stops after 50 iterations or when criterion is under <img class="formulaInl" alt="$ 10^{-4}$" src="form_70.png"/> </li>
</ol>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_{\mu_\text{lD}} = C_{\mu_\text{E}}\]" src="form_80.png"/>
</p>
<p> Iterative process with <img class="formulaInl" alt="$J$" src="form_72.png"/> while <img class="formulaInl" alt="$ \text{iteration} &lt; 50 $" src="form_73.png"/> and <img class="formulaInl" alt="$ 10^{-4} &lt; \left\lVert J-C_\mu \right\rVert $" src="form_81.png"/> </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{aligned} J &amp;= \left(\frac{1}{N} \sum_i \left( 0.5 \times\left(C_{\mu_\text{lD}} + C_i \right)\right)^{-1} \right)^{-1}\\ C_{\mu_\text{lD}} &amp;= J \end{aligned}\]" src="form_82.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">covs</td><td>Vector of Covariance Matrix. </td></tr>
    <tr><td class="paramname">mean</td><td>The mean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab95d3f4cb13e4b4c26311e5ba143924c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::MeanLogEuclidian </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>covs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>mean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Log Euclidiean Mean.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_{\mu_\text{lE}} =\exp\left(\frac{1}{N} \sum_i{\log\left(C_i\right)}\right)\]" src="form_79.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">covs</td><td>Vector of Covariance Matrix. </td></tr>
    <tr><td class="paramname">mean</td><td>The mean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aed1d6e65d7dcb047be1b64d9263b8d7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::MeanRiemann </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>covs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>mean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Mean with the Riemannian Mean.<br />
</p><ol type="1">
<li>Compute the Classical Mean <img class="formulaInl" alt="$ C_{\mu_\text{E}} $" src="form_69.png"/> (see <a class="el" href="namespace_geometry.html#a2abb6c24f0a2eb4ccd89a7ecef5d7a28" title="Compute the Euclidian Mean.   ">MeanEuclidian</a>)</li>
<li>Update with an iterative procedure that stops after 50 iterations or when one of two criterions is under <img class="formulaInl" alt="$ 10^{-4}$" src="form_70.png"/> </li>
</ol>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_{\mu_\text{R}} = C_{\mu_\text{E}} \\ \nu=1.0 \\ \tau=+\infty \]" src="form_71.png"/>
</p>
<p> Iterative process with <img class="formulaInl" alt="$J$" src="form_72.png"/> while <img class="formulaInl" alt="$ \text{iteration} &lt; 50 $" src="form_73.png"/> and <img class="formulaInl" alt="$ 10^{-4} &lt; \left\lVert J \right\rVert $" src="form_74.png"/> and <img class="formulaInl" alt="$ 10^{-4} &lt; \nu $" src="form_75.png"/> </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{aligned} J &amp;= \frac{1}{N} \sum_i \log\left(C_{\mu_\text{R}}^{-1/2} + C_i ~ C_{\mu_\text{R}}^{-1/2}\right)\\ C_{\mu_\text{R}} &amp;= C_{\mu_\text{R}}^{1/2} ~ \exp(\nu \times J) ~ C_{\mu_\text{R}}^{1/2}\\ \end{aligned} \]" src="form_76.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{cases} \text{if } \nu \times \left\lVert J \right\rVert &lt; \tau &amp; \nu = 0.95 \times \nu,~\tau = \nu \times \left\lVert J \right\rVert\\ \text{otherwise } &amp; \nu = 0.5 \times \nu \end{cases} \]" src="form_77.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">covs</td><td>Vector of Covariance Matrix. </td></tr>
    <tr><td class="paramname">mean</td><td>The mean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a406589cb31e0f582b9c9221e6f2438ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::MeanWasserstein </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>covs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>mean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Wasserstein Mean.<br />
</p><ol type="1">
<li>Compute the Classical Mean <img class="formulaInl" alt="$ C_{\mu_\text{E}} $" src="form_69.png"/> (see <a class="el" href="namespace_geometry.html#a2abb6c24f0a2eb4ccd89a7ecef5d7a28" title="Compute the Euclidian Mean.   ">MeanEuclidian</a>)</li>
<li>Update with an iterative procedure that stops after 50 iterations or when criterion is under <img class="formulaInl" alt="$ 10^{-4}$" src="form_70.png"/> </li>
</ol>
</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ C_{\mu_\text{W}} = C_{\mu_{\text{E}}}\]" src="form_84.png"/>
</p>
<p> Iterative process with <img class="formulaInl" alt="$J$" src="form_72.png"/> while <img class="formulaInl" alt="$ \text{iteration} &lt; 50 $" src="form_73.png"/> and <img class="formulaInl" alt="$ 10^{-4} &lt; \left\lVert J-J_{-1} \right\rVert $" src="form_85.png"/> </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{aligned} J &amp;= C_{\mu_\text{W}}^{1/2}\\ J &amp;= \left(\frac{1}{N} \sum_i \left( J C_i J \right)^{1/2} \right)^{1/2}\\ \end{aligned}\]" src="form_86.png"/>
</p>
<p> After the Iterative process : <img class="formulaInl" alt="$ C_{\mu_\text{W}} = J*J $" src="form_87.png"/> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">covs</td><td>Vector of Covariance Matrix. </td></tr>
    <tr><td class="paramname">mean</td><td>The mean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Doesn't work so good (after <img class="formulaInl" alt="$10^{-3}$" src="form_67.png"/> precision with the pyriemann library). </dd></dl>

</div>
</div>
<a class="anchor" id="a3398441a105c55745771f8cc0ba4df00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Geometry::Median </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the median of stl vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the values (only arithmetic type). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the vector of values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The median of vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ad58f4c5c183e4368cf33ca1d669e4322"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Geometry::Median </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the median of values of the Eigen Matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The median of matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b864473632f514fb5c9edb56312e9f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::Median </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>median</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.0001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxIter</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5">EMetric</a> &amp;&#160;</td>
          <td class="paramname"><em>metric</em> = <code><a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5aedca8775d78e240ca6902e89c60621bb">EMetric::Euclidian</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the median of vector of matrix with the Weiszfeld's algorithm for Euclidian Metric and Riemman Barycentre. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrices</td><td>Vector of Matrix. </td></tr>
    <tr><td class="paramname">median</td><td>The computed median. </td></tr>
    <tr><td class="paramname">epsilon</td><td>(Optional) The epsilon value to stop algorithm. </td></tr>
    <tr><td class="paramname">maxIter</td><td>(Optional) The maximum iteration allowed to find best Median. </td></tr>
    <tr><td class="paramname">metric</td><td>(Optional) THe metric to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>
<p>it's an iteratively algorithm, so we have a limit of iteration and an epsilon value to consider the calculation as satisfactory. </p>

</div>
</div>
<a class="anchor" id="a4322a29f9781f937dc5fe0e0bbe9cdcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::MedianEuclidian </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>median</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.0001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxIter</em> = <code>50</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the median of vector of matrix with the Weiszfeld's algorithm. <br />
 To compute this median, we start by computing the initial median of the dataset by taking each element of the matrices independently. That is to say that for the element at position i, j(a_i, j) of the matrices, we computes the median of the elements a_i, j of all the matrices of the dataset. We thus have an initial median for our dataset. <br />
 Then, we refine our median by the iterative algorithm of Weiszfeld: </p>
<ul>
<li>We remove the median in our dataset.</li>
<li>For each new matrices, we compute the norm.</li>
<li>We sum the the matrices in initial dataset (divided by their own norm) and we normalize the result by the sum of inverse norms.</li>
<li>We iterate this previous step until we have a difference between the old and new median is under an epsilon or that the number of iterations is above the limit. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrices</td><td>Vector of Matrix. </td></tr>
    <tr><td class="paramname">median</td><td>The computed median. </td></tr>
    <tr><td class="paramname">epsilon</td><td>(Optional) The epsilon value to stop algorithm. </td></tr>
    <tr><td class="paramname">maxIter</td><td>(Optional) The maximum iteration allowed to find best Median. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>
<p>it's an iteratively algorithm, so we have a limit of iteration and an epsilon value to consider the calculation as satisfactory. </p>

</div>
</div>
<a class="anchor" id="ae832de6c0cee498670b1093f4528b031"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::MedianIdentity </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>median</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give the identity matrix has median. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrices</td><td>Vector of Matrix. </td></tr>
    <tr><td class="paramname">median</td><td>The computed median. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f7027dd258b94e5abc3f99361598ac9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::MedianRiemann </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>median</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.0001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>maxIter</em> = <code>50</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the median of vector of matrix with the Riemman Barycentre. <br />
 </p>
<ul>
<li>Initialize the median with the euclidian mean of matrices.</li>
<li>Iterate until the stop criterion (<code>iteration</code> over <code>maxIter</code> or <img class="formulaInl" alt="$\text{gain}$" src="form_96.png"/> under <code>epsilon</code>).<ul>
<li>Compute the tangent space projection of each matrices with median as reference.</li>
<li>Compute the sum ( <img class="formulaInl" alt="$\mathcal{S}$" src="form_97.png"/>) of euclidian distance of each tangent space projection. <br />
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \delta_E=\sqrt{\sum_{i \in N}{x_i^2}} \quad \text{with } x_i \text{ the feature } i \text{ of the tangent space projection}\]" src="form_98.png"/>
</p>
</li>
<li>Compare with previous sum and stop if <img class="formulaInl" alt="$\text{gain} &lt; \varepsilon$" src="form_99.png"/>. <br />
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \text{gain} = \left|\frac{\mathcal{S} - \mathcal{S}_\text{prev}}{\mathcal{S}_\text{prev}}\right| \]" src="form_100.png"/>
</p>
</li>
<li>Compute Median of each feature <img class="formulaInl" alt="$i$" src="form_101.png"/> of tangent space projection.</li>
<li>Transform this tangent space projection median to riemann space with previous median as reference and update the median by this new matrix. </li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrices</td><td>Vector of Matrix. </td></tr>
    <tr><td class="paramname">median</td><td>The computed median. </td></tr>
    <tr><td class="paramname">epsilon</td><td>(Optional) The epsilon value to stop algorithm. </td></tr>
    <tr><td class="paramname">maxIter</td><td>(Optional) The maximum iteration allowed to find best Median. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="acaf7b067cd0064418504f7f5295ef672"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; Geometry::RoundIndexRange </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>closed</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>unique</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a range of index with double value rounded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Begin of the range. </td></tr>
    <tr><td class="paramname">end</td><td>End of the range. </td></tr>
    <tr><td class="paramname">step</td><td>Step of the range. </td></tr>
    <tr><td class="paramname">closed</td><td>Autorize the end in range if <code>True</code>. </td></tr>
    <tr><td class="paramname">unique</td><td>Remove duplicate value if <code>True</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The range vector. </dd></dl>
<p>Use <a href="https://en.cppreference.com/w/cpp/algorithm/iota">std::iota</a> function and a struct for this specific used. </p>

</div>
</div>
<a class="anchor" id="a3c58e4b585bd4636bc884fe179edc415"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::ShrunkCovariance </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>cov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shrinkage</em> = <code>0.1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrunks the Covariance Matrix <img class="formulaInl" alt="$ M $" src="form_24.png"/> (destructive operation).<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ (1 - \text{shrinkage}) \times M_{\operatorname{Cov}} + \frac{\text{shrinkage} \times \operatorname{trace}(M_{Cov})}{N} \times I_N \]" src="form_25.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cov</td><td>The Covariance Matrix to shrink. </td></tr>
    <tr><td class="paramname">shrinkage</td><td>(Optional) The shrinkage coefficient : <img class="formulaInl" alt="$ 0\leq \text{shrinkage} \leq 1$" src="form_26.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a52f7e1777e1af401c001fcf4295bfd4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::ShrunkCovariance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shrinkage</em> = <code>0.1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrunks the Covariance Matrix <img class="formulaInl" alt="$ M $" src="form_24.png"/> (non destructive operation).<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ (1 - \text{shrinkage}) \times M_{\operatorname{Cov}} + \frac{\text{shrinkage} \times \operatorname{trace}(M_{Cov})}{N} \times I_N \]" src="form_25.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The covariance matrix to shrink. </td></tr>
    <tr><td class="paramname">out</td><td>The shrunk covariance matrix. </td></tr>
    <tr><td class="paramname">shrinkage</td><td>(Optional) The shrinkage coefficient : <img class="formulaInl" alt="$ 0\leq \text{shrinkage} \leq 1$" src="form_26.png"/>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab220baebcbe814fe683a85050c3dd981"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::sortedEigenVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5">EMetric</a>&#160;</td>
          <td class="paramname"><em>metric</em> = <code><a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5aedca8775d78e240ca6902e89c60621bb">EMetric::Euclidian</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute sorted eigen vector of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>the input matrix. </td></tr>
    <tr><td class="paramname">vectors</td><td>Sorted eigen vectors. </td></tr>
    <tr><td class="paramname">values</td><td>Sorted eigen values. </td></tr>
    <tr><td class="paramname">metric</td><td>metric used for vectors. </td></tr>
  </table>
  </dd>
</dl>
<p>Actually only euclidian method is implemented. <br />
 For Riemmanian metric, we must have some optimisation algorithm. </p>

</div>
</div>
<a class="anchor" id="a7529f337a4e676a3eb3d76bcfc389bdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Geometry::Split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the string split by the <code>sep</code> parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to split. </td></tr>
    <tr><td class="paramname">sep</td><td>the separator string which splits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of string part. </dd></dl>

</div>
</div>
<a class="anchor" id="ae65d5cf9573f3592a79104926a9db4f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::SqueezeUpperTriangle </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rowMajor</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Squeeze the upper triangle of <img class="formulaInl" alt="$N \times N$" src="form_47.png"/> square matrix to a <img class="formulaInl" alt="$\frac{N\left(N+1\right)}{2}$" src="form_48.png"/> Vector. </p>
<table  align="center" border="0">
<tr>
<th>Upper Triangle Matrix</th><th></th><th>Row Major Upper Triangle Squeeze </th><th></th><th>Diagonal Major Upper Triangle Squeeze </th></tr>
<tr>
<td><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{pmatrix} a&amp;b&amp;c\\d&amp;e&amp;f\\g&amp;h&amp;i \end{pmatrix} \Rightarrow \begin{pmatrix} a&amp;b&amp;c\\0&amp;e&amp;f\\0&amp;0&amp;i \end{pmatrix} \]" src="form_49.png"/>
</p>
 </td><td><pre>       </pre> </td><td><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{pmatrix} a&amp;b&amp;c\\d&amp;e&amp;f\\g&amp;h&amp;i \end{pmatrix} \Rightarrow \begin{pmatrix} a&amp;b&amp;c&amp;e&amp;f&amp;i \end{pmatrix} \]" src="form_50.png"/>
</p>
 </td><td><pre>       </pre> </td><td><p class="formulaDsp">
<img class="formulaDsp" alt="\[\begin{pmatrix} a&amp;b&amp;c\\d&amp;e&amp;f\\g&amp;h&amp;i \end{pmatrix} \Rightarrow \begin{pmatrix} a&amp;e&amp;i&amp;b&amp;f&amp;c \end{pmatrix} \]" src="form_51.png"/>
</p>
 </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The <img class="formulaInl" alt="$N \times N$" src="form_47.png"/> square matrix. </td></tr>
    <tr><td class="paramname">out</td><td>The <img class="formulaInl" alt="$\frac{N\left(N+1\right)}{2}$" src="form_48.png"/> Vector. </td></tr>
    <tr><td class="paramname">rowMajor</td><td>Get the values row by row if true, diagonal by diagonal if false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a089775c8f69783a27a056cf0dc28b749"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_geometry.html#ac55ab4136356f33e78b9ec964767f29a">EAdaptations</a> Geometry::StringToAdaptation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert string to adaptations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of adaptation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespace_geometry.html#ac55ab4136356f33e78b9ec964767f29a" title="Enumeration of Adaptation Methods for classifier. ">EAdaptations</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4ed5d3175454a36e51fe88e3f1c1a74a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9">EEstimator</a> Geometry::StringToEstimator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>estimator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert string to estimators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">estimator</td><td>The estimator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9" title="Enumeration of the covariance matrix estimator. Inspired by the work of Alexandre Barachant : pyRiema...">EEstimator</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abbf8bad224ae9cd9a28a604716823cdb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_geometry.html#a41128205b080c60f7031983dd6cab9a5">EMatrixClassifiers</a> Geometry::StringToMatrixClassifier </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert string to Matrix Classifiers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of classifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespace_geometry.html#a41128205b080c60f7031983dd6cab9a5" title=" ">EMatrixClassifiers</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a52ccff0c2616d30637002c57b8d98c6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5">EMetric</a> Geometry::StringToMetric </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>metric</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert string to metric. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metric</td><td>The metric. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5" title="Enumeration of metrics. Inspired by the work of Alexandre Barachant : pyRiemann. ">EMetric</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adcbe7965035abc75c92513d07231c1e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::TangentSpace </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>ref</em> = <code>Eigen::MatrixXd()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project a covariance matrices ( <img class="formulaInl" alt="$M$" src="form_54.png"/>) in the tangent space ( <img class="formulaInl" alt="$\mathcal{T}$" src="form_55.png"/>) according to the given reference point ( <img class="formulaInl" alt="$M_\text{Ref}$" src="form_56.png"/>). <br />
 </p>
<ul>
<li>Compute the transformation matrix for the covariance matrix <img class="formulaInl" alt="$M$" src="form_54.png"/> with the reference matrix <img class="formulaInl" alt="$M_\text{Ref}$" src="form_56.png"/> and squeeze ths matrix (see <a class="el" href="namespace_geometry.html#ae65d5cf9573f3592a79104926a9db4f9" title="Squeeze the upper triangle of  square matrix to a  Vector. ">SqueezeUpperTriangle</a>). <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{aligned} J &amp;= \log{\left(M_\text{Ref}^{-1/2} \times M \times M_\text{Ref}^{-1/2}\right)}\\ V_J &amp;= \operatorname{SqueezeUpperTriangle}(J) \end{aligned} \]" src="form_57.png"/>
</p>
</li>
<li>Compute a coefficient Vector to apply to transformation vector. <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{aligned} M_\text{Coeffs} &amp;= \begin{pmatrix} 1 &amp; \sqrt{2} &amp; \cdots &amp; \sqrt{2} \\ 0 &amp; 1 &amp; \ddots &amp; \sqrt{2} \\ \vdots &amp; \ddots &amp; \ddots &amp; \vdots\\ 0 &amp; \cdots &amp; \cdots &amp; 1 \end{pmatrix}\\ V_\text{Coeffs} &amp;= \operatorname{SqueezeUpperTriangle}(M_\text{Coeffs})\\ \end{aligned} \]" src="form_58.png"/>
</p>
</li>
<li>Compute the element wise product of the two vectors to have the tangent space Projection <img class="formulaInl" alt="$\zeta_M$" src="form_59.png"/> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \zeta_M = V_J \odot V_\text{Coeffs} \]" src="form_60.png"/>
</p>
 </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The <img class="formulaInl" alt="$N \times N$" src="form_47.png"/> covariance matrix. </td></tr>
    <tr><td class="paramname">out</td><td>The <img class="formulaInl" alt="$\frac{N\left(N+1\right)}{2}$" src="form_48.png"/> row. </td></tr>
    <tr><td class="paramname">ref</td><td>(Optional) The <img class="formulaInl" alt="$N \times N$" src="form_47.png"/> reference in (use the identity Matrix if empty). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a416ad1cc4a49ee932341656dbde006c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Geometry::toString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_geometry.html#ac55ab4136356f33e78b9ec964767f29a">EAdaptations</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert adaptations to string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of adaptation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::string</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a5b695df8e8d0ebf33ef1c6a85614ed6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Geometry::toString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_geometry.html#ae7b2f142b97d4b99fa2327f29b9c5bf5">EMetric</a>&#160;</td>
          <td class="paramname"><em>metric</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert metric to string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metric</td><td>The metric. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::string</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a934bd571b9ec83389ad5bd5cc2fa53bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Geometry::toString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_geometry.html#abc5f0ced7932cbe299c3631735d6e9e9">EEstimator</a>&#160;</td>
          <td class="paramname"><em>estimator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert estimators to string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">estimator</td><td>The estimator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::string</code> </dd></dl>

</div>
</div>
<a class="anchor" id="af784546f257d3f1ce6f6b4eb3b96b466"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Geometry::toString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_geometry.html#a41128205b080c60f7031983dd6cab9a5">EMatrixClassifiers</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert Matrix Classifiers to string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of classifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::string</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a523323724beb9c8e14ae54cbb01c5ec1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::UnFeaturization </td>
          <td>(</td>
          <td class="paramtype">const Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tangent</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>ref</em> = <code>Eigen::MatrixXd()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the covariance matrix of features vector with the selected method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The Feature Vector. </td></tr>
    <tr><td class="paramname">out</td><td>The covariance out. </td></tr>
    <tr><td class="paramname">tangent</td><td>(Optional) True to use tangent space featurization, Upper Triangle Squeeze if false. </td></tr>
    <tr><td class="paramname">ref</td><td>The reference Matrix (usefull for Tangent Space Featurization). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ac6eaab76672ed2c5df782812bf3d5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::UnSqueezeUpperTriangle </td>
          <td>(</td>
          <td class="paramtype">const Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rowMajor</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the upper triangle of <img class="formulaInl" alt="$\frac{N\left(N+1\right)}{2}$" src="form_48.png"/> Vector to a <img class="formulaInl" alt="$N \times N$" src="form_47.png"/> square matrix. </p>
<table  align="center" border="0">
<tr>
<th>Row Major Method </th><th></th><th>Diagonal Major Method </th></tr>
<tr>
<td><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{pmatrix} a&amp;b&amp;c&amp;d&amp;e&amp;f \end{pmatrix} \Rightarrow \begin{pmatrix} a&amp;b&amp;c\\0&amp;d&amp;e\\0&amp;0&amp;f \end{pmatrix} \]" src="form_52.png"/>
</p>
 </td><td><pre>       </pre> </td><td><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{pmatrix} a&amp;b&amp;c&amp;d&amp;e&amp;f \end{pmatrix} \Rightarrow \begin{pmatrix} a&amp;d&amp;f\\0&amp;b&amp;e\\0&amp;0&amp;c \end{pmatrix} \]" src="form_53.png"/>
</p>
 </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The <img class="formulaInl" alt="$\frac{N\left(N+1\right)}{2}$" src="form_48.png"/> Vector. </td></tr>
    <tr><td class="paramname">out</td><td>The <img class="formulaInl" alt="$N \times N$" src="form_47.png"/> square matrix. </td></tr>
    <tr><td class="paramname">rowMajor</td><td>Get the values row by row if true, diagonal by diagonal if false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a30f5572bcfe17760736d45a0d4d04430"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::UnTangentSpace </td>
          <td>(</td>
          <td class="paramtype">const Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>ref</em> = <code>Eigen::MatrixXd()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project a Tangent space vectors in the manifold according to the given reference point. <br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{aligned} \text{With : } M_\text{Ts} &amp;= \operatorname{UnSqueezeUpperTriangle}(V_\text{Ts}) \quad \text{ and } \quad \mathsf{U}_{M}\text{ the upper triangular out.}\\ M_\text{Coeffs} &amp;= \operatorname{diag}\left(M_\text{Ts}\right) + \frac{\mathsf{U}_{M_\text{Ts}} + \mathsf{U}_{M_\text{Ts}}^{\mathsf{T}}}{\sqrt{2}}\\ \Rightarrow M &amp;= M_\text{Ref}^{1/2} ~ \exp{\left(M_\text{Coeffs}\right)} ~ M_\text{Ref}^{1/2} \end{aligned} \]" src="form_61.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The <img class="formulaInl" alt="$\frac{N\left(N+1\right)}{2}$" src="form_48.png"/> row. </td></tr>
    <tr><td class="paramname">out</td><td>The <img class="formulaInl" alt="$N \times N$" src="form_47.png"/> covariance matrix. </td></tr>
    <tr><td class="paramname">ref</td><td>(Optional) The <img class="formulaInl" alt="$N \times N$" src="form_47.png"/> reference out (use the identity Matrix if empty). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>True</code> if it succeeds, <code>False</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a91b0a15045364dad7728f02677c1051c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Geometry::Variance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculation of the Variance of a double dataset <img class="formulaInl" alt="$\vec{X}$" src="form_18.png"/>.<br />
 </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ V(X) = \left(\frac{1}{n} \sum_{i=1}^{N}x_{i}^{2}\right) - \left(\frac{1}{n} \sum_{i=1}^{N}x_{i}\right)^{2} \]" src="form_19.png"/>
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The dataset <img class="formulaInl" alt="$\vec{X}$" src="form_18.png"/>. With <img class="formulaInl" alt="$ N $" src="form_20.png"/> Samples. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Variance. </dd></dl>

</div>
</div>
<a class="anchor" id="a0243494a4064279207a0484869dc1364"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;T&gt; &gt; Geometry::Vector1DTo2D </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn vector into vector of vector with position repartition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Generic type parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>vector of vector. </td></tr>
    <tr><td class="paramname">position</td><td>position of element (size of position is the number of row the values are the number of element on each row). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>vector&lt;T&gt;</code> </dd></dl>

</div>
</div>
<a class="anchor" id="af5a37063547677cd920a80025da46634"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; Geometry::Vector2DTo1D </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn vector of vector into vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Generic type parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>vector of vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>vector&lt;T&gt;</code> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
